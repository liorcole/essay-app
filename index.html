<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Gap</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: #0a0a0f;
            color: #e8e8e8;
            min-height: 100vh;
            line-height: 1.8;
        }

        .essay-container {
            max-width: 720px;
            margin: 0 auto;
            padding: 80px 40px;
        }

        /* ========== ESSAY TEXT STYLES ========== */
        /* Edit the text content in the HTML below */

        .section {
            margin-bottom: 60px;
        }

        .paragraph {
            font-size: 1.25rem;
            margin-bottom: 1.5em;
            color: #d0d0d0;
        }

        .paragraph strong {
            color: #ffffff;
            font-weight: 600;
        }

        .emphasis {
            font-style: italic;
            color: #a8a8a8;
        }

        .parenthetical {
            color: #888;
            font-size: 1.1rem;
        }

        .main-thesis {
            font-size: 1.75rem;
            font-weight: 500;
            color: #ffffff;
            margin-bottom: 2em;
            line-height: 1.5;
        }

        /* ========== STICKY NOTE ========== */

        .identity-container,
        .reality-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            margin: 50px 0;
        }

        .identity-container .paragraph,
        .reality-container .paragraph {
            flex: 0 0 70%;
            margin-bottom: 0;
        }

        .sticky-note {
            flex: 0 0 260px;
            padding: 20px;
            background: #fef08a;
            color: #1a1a1a;
            font-family: 'Georgia', serif;
            font-size: 0.9rem;
            line-height: 1.5;
            cursor: pointer;
            box-shadow: 4px 4px 12px rgba(0, 0, 0, 0.3);
            transform: rotate(2deg);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .sticky-note:hover {
            transform: rotate(0deg) scale(1.02);
            box-shadow: 6px 6px 16px rgba(0, 0, 0, 0.4);
        }

        .sticky-note-heading {
            font-weight: 700;
            font-size: 1.1rem;
            margin-bottom: 10px;
            color: #333;
            text-transform: lowercase;
        }

        .sticky-note-front {
            font-style: italic;
            color: #666;
            text-align: center;
        }

        .sticky-note-content {
            display: none;
        }

        .sticky-note.revealed .sticky-note-front {
            display: none;
        }

        .sticky-note.revealed .sticky-note-content {
            display: block;
        }

        .identity-container .sticky-note {
            background: #bfdbfe;
        }

        .reality-container .sticky-note {
            background: #bfdbfe;
        }

        /* ========== SHADED BOX ========== */

        .shaded-box {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 40px;
            margin: 40px 0;
        }

        .shaded-box-title {
            font-size: 1rem;
            font-weight: 500;
            color: #888;
            text-transform: lowercase;
            margin-bottom: 20px;
            letter-spacing: 0.1em;
        }

        .shaded-box .paragraph {
            margin-bottom: 1.5em;
        }

        .shaded-box .paragraph:last-child {
            margin-bottom: 0;
        }

        .diagram-placeholder {
            min-height: 200px;
            margin-bottom: 30px;
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.3);
        }

        /* ========== BODY DIAGRAM ========== */

        .body-diagram {
            position: relative;
            width: 240px;
            height: 320px;
            margin: 40px auto;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .body-click-hint {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            font-style: italic;
            color: #888;
            font-size: 0.9rem;
            transition: opacity 0.3s ease;
        }

        .body-diagram.revealed .body-click-hint {
            opacity: 0;
        }

        .body-diagram-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 60px auto;
        }

        .body-diagram {
            transition: all 0.6s ease-out;
        }

        /* Expanded state when "do" is clicked */
        .body-diagram.expanded {
            width: 800px;
            height: 750px;
        }

        .body-diagram.expanded .infinity-bubble {
            width: 800px;
            height: 750px;
        }

        .body-diagram.expanded .sense-blocks-container {
            opacity: 0;
        }

        .body-diagram.expanded .body-image {
            transform: translateY(150px);
            transition: transform 0.6s ease-out;
        }

        .body-diagram.expanded .limited-body-image {
            transform: translate(-50%, -50%) translateY(150px);
            transition: transform 0.6s ease-out;
        }

        .orb-text {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            text-align: center;
            font-size: 1rem;
            color: #d0d0d0;
            line-height: 1.7;
            opacity: 0;
            transition: opacity 0.5s ease-out 0.3s;
            z-index: 10;
        }

        .body-diagram.expanded .orb-text {
            opacity: 1;
        }

        .body-diagram.expanded .infinity-bubble {
            opacity: 1;
        }

        .body-diagram.expanded {
            cursor: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="84" height="22"><rect x="0" y="0" width="84" height="22" rx="4" fill="%230a0a0f" stroke="%2386efac" stroke-width="1"/><text x="42" y="15" font-family="Georgia, serif" font-size="11" font-weight="bold" fill="%2386efac" text-anchor="middle">CLICK ME!!</text></svg>') 42 11, pointer;
        }

        /* Scene 2 image for expanded orb */
        .do-scene2-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateY(60px);
            width: 500px;
            height: auto;
            filter: invert(1);
            opacity: 0;
            z-index: 4;
            transition: opacity 0.5s ease;
        }

        .body-diagram.expanded.scene2 .do-scene2-image {
            opacity: 1;
        }

        .body-diagram.expanded.scene2 .body-image,
        .body-diagram.expanded.scene2 .limited-body-image {
            opacity: 0;
        }

        /* Scene 3 image */
        .do-scene3-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateY(60px);
            width: 500px;
            height: auto;
            filter: invert(1);
            opacity: 0;
            z-index: 4;
            transition: opacity 0.5s ease;
        }

        .body-diagram.expanded.scene3 .do-scene3-image {
            opacity: 1;
        }

        .body-diagram.expanded.scene3 .do-scene2-image {
            opacity: 0;
        }

        .body-diagram.expanded.scene3 .body-image,
        .body-diagram.expanded.scene3 .limited-body-image {
            opacity: 0;
        }

        /* Hide scene2 orbs in scene3 */
        .body-diagram.expanded.scene3 .scene2-orb {
            opacity: 0;
        }

        /* Scene 3 green orbs */
        .scene3-orb {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            z-index: 20;
            opacity: 0;
            transition: all 0.5s ease;
            animation: orbPulse 2s ease-in-out infinite;
        }

        .orb-green {
            background: radial-gradient(circle, #86efac 0%, rgba(134, 239, 172, 0.3) 70%, transparent 100%);
            box-shadow: 0 0 10px rgba(134, 239, 172, 0.5);
        }

        .body-diagram.expanded.scene3 .scene3-orb {
            opacity: 1;
        }

        /* Hide the main head-orb in scene3 since we have the two scene3 orbs */
        .body-diagram.expanded.scene3 .head-orb {
            opacity: 0;
        }

        /* Scene 4 - body with graphic beside it */
        .do-scene4-image {
            position: absolute;
            top: 50%;
            left: 65%;
            transform: translateY(-50%) translateY(150px);
            width: 40px;
            height: auto;
            filter: invert(1);
            opacity: 0;
            z-index: 4;
            transition: opacity 0.5s ease;
        }

        .body-diagram.expanded.scene4 .do-scene4-image {
            opacity: 1;
        }

        .body-diagram.expanded.scene4 .do-scene3-image {
            opacity: 0;
        }

        /* Show body again in scene4, same position as scene1 */
        .body-diagram.expanded.scene4 .body-image {
            opacity: 1;
            transform: translateY(150px);
        }

        /* Hide scene3 orbs in scene4 */
        .body-diagram.expanded.scene4 .scene3-orb {
            opacity: 0;
        }

        /* Show head orb again in scene4 */
        .body-diagram.expanded.scene4 .head-orb {
            opacity: 1;
        }

        /* Scene 4 orb for the new graphic */
        .scene4-orb {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            z-index: 20;
            opacity: 0;
            transition: all 0.5s ease;
            animation: orbPulse 2s ease-in-out infinite;
            background: radial-gradient(circle, #86efac 0%, rgba(134, 239, 172, 0.3) 70%, transparent 100%);
            box-shadow: 0 0 10px rgba(134, 239, 172, 0.5);
        }

        .body-diagram.expanded.scene4 .scene4-orb {
            opacity: 1;
        }

        /* Scene 5 - orb travels along path */
        .body-diagram.expanded.scene5 .scene4-orb {
            animation: orbPath 2s ease-in-out forwards;
        }

        .body-diagram.expanded.scene5 .do-scene4-image {
            opacity: 1;
        }

        .body-diagram.expanded.scene5 .body-image {
            opacity: 1;
            transform: translateY(150px);
        }

        @keyframes orbPath {
            0% { left: 62.8%; top: 68.4%; opacity: 1; }
            20% { left: 57.7%; top: 68%; opacity: 1; }
            40% { left: 54.7%; top: 72.1%; opacity: 1; }
            60% { left: 53%; top: 78.1%; opacity: 1; }
            80% { left: 53%; top: 82%; opacity: 1; }
            100% { left: 53.3%; top: 84.9%; opacity: 0; }
        }

        /* Body fill overlay - appears after orb reaches destination */
        .body-fill-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 140px;
            height: auto;
            filter: invert(1);
            opacity: 0;
            z-index: 5;
            pointer-events: none;
        }

        .body-diagram.expanded.scene5 .body-fill-overlay {
            transform: translate(-50%, -50%) translateY(150px);
            animation: showBodyFill 0.5s ease-out forwards;
            animation-delay: 2s;
        }

        @keyframes showBodyFill {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }

        /* Scene 6 - room with text, hide clipboard and orb */
        .body-diagram.expanded.scene6 .do-scene4-image {
            opacity: 0;
        }

        .body-diagram.expanded.scene6 .scene4-orb {
            opacity: 0;
        }

        .scene6-text {
            position: absolute;
            top: 130px;
            left: 50%;
            transform: translateX(-50%);
            width: 85%;
            text-align: center;
            font-size: 0.95rem;
            color: white;
            opacity: 0;
            z-index: 10;
            line-height: 1.5;
        }

        .body-diagram.expanded.scene6 .scene6-text,
        .body-diagram.expanded.scene7 .scene6-text,
        .body-diagram.expanded.scene8 .scene6-text,
        .body-diagram.expanded.scene9 .scene6-text,
        .body-diagram.expanded.scene10 .scene6-text {
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        /* Hide scene6 text in scene11+ */
        .body-diagram.expanded.scene11 .scene6-text {
            opacity: 0;
        }

        /* Scene 12 text */
        .scene12-text {
            position: absolute;
            top: 130px;
            left: 50%;
            transform: translateX(-50%);
            width: 85%;
            text-align: center;
            font-size: 0.95rem;
            color: white;
            opacity: 0;
            z-index: 10;
            line-height: 1.5;
        }

        .body-diagram.expanded.scene12 .scene12-text {
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        /* Room image for scene 6 */
        .room-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateY(80px);
            width: 500px;
            height: auto;
            filter: invert(1);
            opacity: 0;
            z-index: 6;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .body-diagram.expanded.scene6 .room-image {
            opacity: 1;
        }

        /* Hide body, fill, and head orb in scene6+ when room shows - same pattern as scene2/3 */
        .body-diagram.expanded.scene6 .body-image,
        .body-diagram.expanded.scene6 .body-fill-overlay,
        .body-diagram.expanded.scene6 .head-orb,
        .body-diagram.expanded.scene6 .limited-body-image,
        .body-diagram.expanded.scene7 .body-image,
        .body-diagram.expanded.scene7 .body-fill-overlay,
        .body-diagram.expanded.scene7 .head-orb,
        .body-diagram.expanded.scene7 .limited-body-image,
        .body-diagram.expanded.scene8 .body-image,
        .body-diagram.expanded.scene8 .body-fill-overlay,
        .body-diagram.expanded.scene8 .head-orb,
        .body-diagram.expanded.scene8 .limited-body-image,
        .body-diagram.expanded.scene9 .body-image,
        .body-diagram.expanded.scene9 .body-fill-overlay,
        .body-diagram.expanded.scene9 .head-orb,
        .body-diagram.expanded.scene9 .limited-body-image,
        .body-diagram.expanded.scene10 .body-image,
        .body-diagram.expanded.scene10 .body-fill-overlay,
        .body-diagram.expanded.scene10 .head-orb,
        .body-diagram.expanded.scene10 .limited-body-image,
        .body-diagram.expanded.scene11 .body-image,
        .body-diagram.expanded.scene11 .body-fill-overlay,
        .body-diagram.expanded.scene11 .head-orb,
        .body-diagram.expanded.scene11 .limited-body-image {
            opacity: 0 !important;
            animation: none !important;
        }

        /* Room sequence images (scenes 7-11) */
        .room1-image, .room2-image, .room3-image, .room4-image, .room5-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateY(80px);
            width: 500px;
            height: auto;
            filter: invert(1);
            opacity: 0;
            z-index: 6;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        /* Scene 7 - room1 with 1 orb */
        .body-diagram.expanded.scene7 .room-image { opacity: 0; }
        .body-diagram.expanded.scene7 .room1-image { opacity: 1; }

        /* Scene 8 - room2 with 2 orbs */
        .body-diagram.expanded.scene8 .room1-image { opacity: 0; }
        .body-diagram.expanded.scene8 .room2-image { opacity: 1; }

        /* Scene 9 - room3 with 4 orbs */
        .body-diagram.expanded.scene9 .room2-image { opacity: 0; }
        .body-diagram.expanded.scene9 .room3-image { opacity: 1; }

        /* Scene 10 - room4 with 5 orbs */
        .body-diagram.expanded.scene10 .room3-image { opacity: 0; }
        .body-diagram.expanded.scene10 .room4-image { opacity: 1; }

        /* Scene 11 - room4 stays during animation */
        .body-diagram.expanded.scene11 .room4-image { opacity: 1; }
        .body-diagram.expanded.scene11 .room5-image { opacity: 0; }

        /* Scene 11 complete - room5 appears after animation */
        .body-diagram.expanded.scene11.animation-complete .room4-image { opacity: 0; }
        .body-diagram.expanded.scene11.animation-complete .room5-image { opacity: 1; }

        /* Scene 12 - hide ALL room images, show read1 with text */
        .body-diagram.expanded.scene12 .room-image,
        .body-diagram.expanded.scene12 .room1-image,
        .body-diagram.expanded.scene12 .room2-image,
        .body-diagram.expanded.scene12 .room3-image,
        .body-diagram.expanded.scene12 .room4-image,
        .body-diagram.expanded.scene12 .room5-image { opacity: 0 !important; }
        .body-diagram.expanded.scene12 .room-orb { opacity: 0 !important; }

        /* Slideshow images for scene 12 */
        .slide-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateY(80px);
            width: 500px;
            height: auto;
            filter: invert(1);
            opacity: 0;
            z-index: 7;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        /* Scene 12 default - show read1 */
        .body-diagram.expanded.scene12 .slide-read1 { opacity: 1; }

        /* Scene 12 slide states - only one image at a time */
        .body-diagram.expanded.scene12.slide-2 .slide-read1 { opacity: 0; }
        .body-diagram.expanded.scene12.slide-2 .slide-read2 { opacity: 1; }

        .body-diagram.expanded.scene12.slide-3 .slide-read1 { opacity: 0; }
        .body-diagram.expanded.scene12.slide-3 .slide-read2 { opacity: 0; }
        .body-diagram.expanded.scene12.slide-3 .slide-school1 { opacity: 1; }

        .body-diagram.expanded.scene12.slide-4 .slide-read1 { opacity: 0; }
        .body-diagram.expanded.scene12.slide-4 .slide-school1 { opacity: 0; }
        .body-diagram.expanded.scene12.slide-4 .slide-school2 { opacity: 1; }

        .body-diagram.expanded.scene12.slide-5 .slide-read1 { opacity: 0; }
        .body-diagram.expanded.scene12.slide-5 .slide-school2 { opacity: 0; }
        .body-diagram.expanded.scene12.slide-5 .slide-conversation1 { opacity: 1; }

        .body-diagram.expanded.scene12.slide-6 .slide-read1 { opacity: 0; }
        .body-diagram.expanded.scene12.slide-6 .slide-conversation1 { opacity: 0; }
        .body-diagram.expanded.scene12.slide-6 .slide-conversation2 { opacity: 1; }

        /* Scene 13 text */
        .scene13-text {
            position: absolute;
            top: 130px;
            left: 50%;
            transform: translateX(-50%);
            width: 85%;
            text-align: center;
            font-size: 0.95rem;
            color: white;
            opacity: 0;
            z-index: 10;
            line-height: 1.5;
        }

        .body-diagram.expanded.scene13 .scene13-text {
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        /* Scene 13 - hide scene 12 stuff, show car images */
        .body-diagram.expanded.scene13 .scene12-text { opacity: 0 !important; }
        .body-diagram.expanded.scene13 .slide-image { opacity: 0 !important; }

        /* Scene 13 default - show car1 */
        .body-diagram.expanded.scene13 .slide-car1 { opacity: 1 !important; }

        /* Scene 13 slide-2 - show car2 */
        .body-diagram.expanded.scene13.slide-2 .slide-car1 { opacity: 0 !important; }
        .body-diagram.expanded.scene13.slide-2 .slide-car2 { opacity: 1 !important; }

        /* Room orbs - all green like head orb */
        .room-orb {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #86efac 0%, rgba(134, 239, 172, 0.3) 70%, transparent 100%);
            border-radius: 50%;
            z-index: 25;
            opacity: 0;
            box-shadow: 0 0 10px rgba(134, 239, 172, 0.5);
            animation: orbPulse 2s ease-in-out infinite;
        }

        /* Orb visibility per scene */
        /* Orb 6 = head orb, shows in all room scenes (6-11) */
        .body-diagram.expanded.scene6 .room-orb[data-room-orb="6"],
        .body-diagram.expanded.scene7 .room-orb[data-room-orb="6"],
        .body-diagram.expanded.scene8 .room-orb[data-room-orb="6"],
        .body-diagram.expanded.scene9 .room-orb[data-room-orb="6"],
        .body-diagram.expanded.scene10 .room-orb[data-room-orb="6"],
        .body-diagram.expanded.scene11 .room-orb[data-room-orb="6"] { opacity: 1; }

        .body-diagram.expanded.scene7 .room-orb[data-room-orb="1"] { opacity: 1; }

        .body-diagram.expanded.scene8 .room-orb[data-room-orb="1"],
        .body-diagram.expanded.scene8 .room-orb[data-room-orb="2"] { opacity: 1; }

        .body-diagram.expanded.scene9 .room-orb[data-room-orb="1"],
        .body-diagram.expanded.scene9 .room-orb[data-room-orb="2"],
        .body-diagram.expanded.scene9 .room-orb[data-room-orb="3"],
        .body-diagram.expanded.scene9 .room-orb[data-room-orb="4"] { opacity: 1; }

        /* Scene 10 - all 5 orbs + head orb visible */
        .body-diagram.expanded.scene10 .room-orb[data-room-orb="1"],
        .body-diagram.expanded.scene10 .room-orb[data-room-orb="2"],
        .body-diagram.expanded.scene10 .room-orb[data-room-orb="3"],
        .body-diagram.expanded.scene10 .room-orb[data-room-orb="4"],
        .body-diagram.expanded.scene10 .room-orb[data-room-orb="5"] { opacity: 1; }

        /* Scene 11 - all 5 orbs visible and animating */
        .body-diagram.expanded.scene11 .room-orb[data-room-orb="1"],
        .body-diagram.expanded.scene11 .room-orb[data-room-orb="2"],
        .body-diagram.expanded.scene11 .room-orb[data-room-orb="3"],
        .body-diagram.expanded.scene11 .room-orb[data-room-orb="4"],
        .body-diagram.expanded.scene11 .room-orb[data-room-orb="5"] { opacity: 1; }

        /* Keep head orb (orb 6) visible in scene11 */
        .body-diagram.expanded.scene11 .room-orb[data-room-orb="6"] { opacity: 1; }

        /* Keyframe animations for each orb to destination (50.2, 66.0) */
        @keyframes orbPath1 {
            0% { left: 29.5%; top: 48.3%; }
            100% { left: 50.2%; top: 66.0%; }
        }

        @keyframes orbPath2 {
            0% { left: 70.2%; top: 48.4%; }
            100% { left: 50.2%; top: 66.0%; }
        }

        @keyframes orbPath3 {
            0% { left: 56.3%; top: 46.4%; }
            100% { left: 50.2%; top: 66.0%; }
        }

        @keyframes orbPath4 {
            0% { left: 80.0%; top: 44.9%; }
            100% { left: 50.2%; top: 66.0%; }
        }

        @keyframes orbPath5 {
            0% { left: 43.4%; top: 47.6%; }
            100% { left: 50.2%; top: 66.0%; }
        }

        .body-diagram.expanded.scene11 .room-orb[data-room-orb="1"] {
            animation: orbPath1 1s ease-out forwards, orbPulse 2s ease-in-out infinite;
        }
        .body-diagram.expanded.scene11 .room-orb[data-room-orb="2"] {
            animation: orbPath2 1s ease-out forwards, orbPulse 2s ease-in-out infinite;
        }
        .body-diagram.expanded.scene11 .room-orb[data-room-orb="3"] {
            animation: orbPath3 1s ease-out forwards, orbPulse 2s ease-in-out infinite;
        }
        .body-diagram.expanded.scene11 .room-orb[data-room-orb="4"] {
            animation: orbPath4 1s ease-out forwards, orbPulse 2s ease-in-out infinite;
        }
        .body-diagram.expanded.scene11 .room-orb[data-room-orb="5"] {
            animation: orbPath5 1s ease-out forwards, orbPulse 2s ease-in-out infinite;
        }

        /* Small green orb in person's head */
        .head-orb {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #86efac 0%, rgba(134, 239, 172, 0.3) 70%, transparent 100%);
            border-radius: 50%;
            z-index: 20;
            opacity: 0;
            transition: all 0.5s ease;
            animation: orbPulse 2s ease-in-out infinite;
        }

        @keyframes orbPulse {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 0 10px rgba(134, 239, 172, 0.5);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                box-shadow: 0 0 20px rgba(134, 239, 172, 0.8);
            }
        }

        /* Orb appears when revealed (infinite) or expanded (do) - position controlled by JavaScript */
        .body-diagram.revealed .head-orb,
        .body-diagram.expanded .head-orb {
            opacity: 1;
        }

        /* Scene 2 colored orbs */
        .scene2-orb {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            z-index: 20;
            opacity: 0;
            transition: all 0.5s ease;
            animation: orbPulse 2s ease-in-out infinite;
        }

        .body-diagram.expanded.scene2 .scene2-orb {
            opacity: 1;
        }

        .orb-blue {
            background: radial-gradient(circle, #60a5fa 0%, rgba(96, 165, 250, 0.3) 70%, transparent 100%);
            box-shadow: 0 0 10px rgba(96, 165, 250, 0.5);
        }
        .orb-purple {
            background: radial-gradient(circle, #c084fc 0%, rgba(192, 132, 252, 0.3) 70%, transparent 100%);
            box-shadow: 0 0 10px rgba(192, 132, 252, 0.5);
        }
        .orb-pink {
            background: radial-gradient(circle, #f472b6 0%, rgba(244, 114, 182, 0.3) 70%, transparent 100%);
            box-shadow: 0 0 10px rgba(244, 114, 182, 0.5);
        }
        .orb-red {
            background: radial-gradient(circle, #f87171 0%, rgba(248, 113, 113, 0.3) 70%, transparent 100%);
            box-shadow: 0 0 10px rgba(248, 113, 113, 0.5);
        }
        .orb-orange {
            background: radial-gradient(circle, #fb923c 0%, rgba(251, 146, 60, 0.3) 70%, transparent 100%);
            box-shadow: 0 0 10px rgba(251, 146, 60, 0.5);
        }
        .orb-yellow {
            background: radial-gradient(circle, #fbbf24 0%, rgba(251, 191, 36, 0.3) 70%, transparent 100%);
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }
        .orb-cyan {
            background: radial-gradient(circle, #22d3d8 0%, rgba(34, 211, 216, 0.3) 70%, transparent 100%);
            box-shadow: 0 0 10px rgba(34, 211, 216, 0.5);
        }
        .orb-white {
            background: radial-gradient(circle, #ffffff 0%, rgba(255, 255, 255, 0.3) 70%, transparent 100%);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .body-image {
            width: 140px;
            height: auto;
            position: relative;
            z-index: 2;
            filter: invert(1) opacity(0.9);
            transition: opacity 0.5s ease;
        }

        .infinity-bubble {
            position: absolute;
            width: 280px;
            height: 360px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
            opacity: 0;
            transition: opacity 0.5s ease, width 0.6s ease-out, height 0.6s ease-out;
            overflow: visible;
        }


        .body-diagram.revealed .infinity-bubble {
            opacity: 1;
        }

        .bubble-path {
            fill: none;
            stroke: #86efac;
            stroke-width: 3;
            animation: wobble 4s ease-in-out infinite;
        }

        @keyframes wobble {
            0%, 100% {
                d: path("M200,20 C320,20 380,80 380,200 C380,320 340,400 280,450 C240,480 160,480 120,450 C60,400 20,320 20,200 C20,80 80,20 200,20");
            }
            25% {
                d: path("M200,25 C330,15 390,90 375,210 C370,330 330,410 270,455 C235,475 165,485 125,445 C55,395 15,310 25,195 C30,75 85,25 200,25");
            }
            50% {
                d: path("M200,15 C315,25 375,75 385,195 C385,315 345,395 285,445 C245,485 155,475 115,455 C65,405 25,325 15,205 C15,85 75,15 200,15");
            }
            75% {
                d: path("M200,22 C325,18 385,85 378,205 C375,325 335,405 275,452 C238,478 162,482 122,448 C58,398 18,315 22,198 C25,78 82,22 200,22");
            }
        }

        .infinity-arrows {
            opacity: 0;
            transition: opacity 0.5s ease 0.3s;
        }

        .body-diagram.revealed .infinity-arrows {
            opacity: 1;
        }

        .arrow {
            fill: none;
            stroke: #86efac;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        /* ========== TOOLTIP ========== */

        .tooltip-trigger {
            position: relative;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-underline-offset: 3px;
            cursor: help;
        }

        .tooltip-content {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            width: 875px;
            padding: 20px 20px 45px 20px;
            background: #1a1a1f;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-size: 0.9rem;
            line-height: 1.6;
            color: #a0a0a0;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 100;
            margin-bottom: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }

        .tooltip-trigger:hover .tooltip-content {
            opacity: 1;
            visibility: visible;
        }

        .tooltip-trigger.highlight {
            font-weight: normal;
            color: white;
            text-decoration: underline;
            text-decoration-style: dotted;
        }

        .tooltip-trigger.highlight .tooltip-content {
            font-weight: normal;
        }

        .tooltip-audio-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
            pointer-events: auto;
        }

        .tooltip-voice-select {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #a0a0a0;
            font-size: 0.7rem;
            padding: 4px 6px;
            cursor: pointer;
            max-width: 150px;
            height: 32px;
        }

        .tooltip-voice-select:hover {
            background: rgba(255, 255, 255, 0.15);
            color: #ffffff;
        }

        .tooltip-voice-select:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.4);
        }

        .tooltip-speed-btn {
            height: 32px;
            padding: 0 8px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #a0a0a0;
            font-size: 0.7rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
            white-space: nowrap;
        }

        .tooltip-speed-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            color: #ffffff;
        }

        .tooltip-audio-btn {
            width: 32px;
            height: 32px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease;
            flex-shrink: 0;
        }

        .tooltip-audio-btn:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .tooltip-audio-btn.playing {
            background: rgba(134, 239, 172, 0.2);
            border-color: rgba(134, 239, 172, 0.4);
        }

        .tooltip-audio-btn svg {
            width: 16px;
            height: 16px;
            fill: #a0a0a0;
        }

        .tooltip-audio-btn:hover svg {
            fill: #ffffff;
        }

        .tooltip-audio-btn.playing svg {
            fill: #86efac;
        }

        .tooltip-content .red-bold {
            color: #ff4444;
            font-weight: bold;
        }

        /* ========== INTERACTIVE KEYWORDS ========== */

        .keyword {
            font-size: 1.5rem;
            font-weight: 700;
            display: inline-block;
            cursor: default;
            transition: transform 0.1s ease-out;
            position: relative;
        }

        .keyword-identity {
            color: #60a5fa;
            text-shadow: 0 0 30px rgba(96, 165, 250, 0.3);
            cursor: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="84" height="22"><rect x="0" y="0" width="84" height="22" rx="4" fill="%230a0a0f" stroke="%2360a5fa" stroke-width="1"/><text x="42" y="15" font-family="Georgia, serif" font-size="11" font-weight="bold" fill="%2360a5fa" text-anchor="middle">CLICK ME!!</text></svg>') 42 11, pointer;
        }

        .keyword-reality {
            color: #60a5fa;
            text-shadow: 0 0 30px rgba(96, 165, 250, 0.3);
            cursor: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="84" height="22"><rect x="0" y="0" width="84" height="22" rx="4" fill="%230a0a0f" stroke="%2360a5fa" stroke-width="1"/><text x="42" y="15" font-family="Georgia, serif" font-size="11" font-weight="bold" fill="%2360a5fa" text-anchor="middle">CLICK ME!!</text></svg>') 42 11, pointer;
        }

        .keyword-gap {
            color: #86efac;
            text-shadow: 0 0 30px rgba(134, 239, 172, 0.3);
            cursor: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="84" height="22"><rect x="0" y="0" width="84" height="22" rx="4" fill="%230a0a0f" stroke="%2386efac" stroke-width="1"/><text x="42" y="15" font-family="Georgia, serif" font-size="11" font-weight="bold" fill="%2386efac" text-anchor="middle">CLICK ME!!</text></svg>') 42 11, pointer;
        }

        .keyword.hovering {
            transform: translate(var(--hover-x, 0), var(--hover-y, 0));
        }

        .keyword.flashing {
            animation: keywordFlash 0.5s ease-out;
        }

        @keyframes keywordFlash {
            0%, 100% { opacity: 1; }
            25% { opacity: 0.3; }
            50% { opacity: 1; }
            75% { opacity: 0.3; }
        }

        .keyword.auto-trigger {
            transform: scale(1.5);
            transition: transform 0.3s ease-out;
        }

        .keyword.auto-trigger-shrink {
            transform: scale(1);
            transition: transform 0.3s ease-out;
        }

        /* ========== GAP ARROW ANIMATION ========== */

        .gap-arrow-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .gap-arrow-line {
            fill: none;
            stroke: #86efac;
            stroke-width: 3;
            stroke-linecap: round;
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
        }

        .gap-arrow-line.animating {
            animation: drawArrow 0.6s ease-out forwards;
        }

        @keyframes drawArrow {
            to {
                stroke-dashoffset: 0;
            }
        }

        .gap-arrow-head {
            fill: #86efac;
            opacity: 0;
        }

        .gap-arrow-head.animating {
            animation: showArrowHead 0.2s ease-out 0.5s forwards;
        }

        @keyframes showArrowHead {
            to {
                opacity: 1;
            }
        }

        /* Permanent faint green fill when revealed */
        .bubble-fill-green {
            fill: rgba(134, 239, 172, 0.15);
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .body-diagram.revealed .bubble-fill-green {
            opacity: 1;
        }

        /* Green flash fill effect for the gap */
        .bubble-fill-flash {
            fill: rgba(134, 239, 172, 0.5);
            opacity: 0;
            transition: opacity 0.1s ease;
        }

        .body-diagram.flash-fill .bubble-fill-flash {
            animation: flashFill 2s ease-out;
        }

        @keyframes flashFill {
            0% { opacity: 0; }
            15% { opacity: 0.6; }
            30% { opacity: 0.35; }
            50% { opacity: 0.5; }
            70% { opacity: 0.3; }
            85% { opacity: 0.15; }
            100% { opacity: 0; }
        }

        /* Body mask to cut out body shape from fill */
        .body-diagram .body-image {
            position: relative;
            z-index: 3;
        }

        /* Limited sequence body images */
        .limited-body-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 140px;
            height: auto;
            filter: invert(1);
            opacity: 0;
            z-index: 4;
            transition: opacity 0.5s ease;
        }

        .limited-body-image.visible {
            opacity: 1;
        }

        /* body5 - inverted like the others, higher z-index to show on top */
        #body5-img {
            filter: invert(1);
            z-index: 10;
        }

        /* Make sure body5 shows on top when visible (but not in later scenes) */
        #body5-img.visible {
            opacity: 1;
        }

        /* Hide body5 in scenes 5+ (keep visible in scene4 for "relief in diagnosis" text) */
        .body-diagram.expanded.scene5 #body5-img,
        .body-diagram.expanded.scene6 #body5-img,
        .body-diagram.expanded.scene7 #body5-img,
        .body-diagram.expanded.scene8 #body5-img,
        .body-diagram.expanded.scene9 #body5-img,
        .body-diagram.expanded.scene10 #body5-img,
        .body-diagram.expanded.scene11 #body5-img,
        .body-diagram.expanded.scene12 #body5-img,
        .body-diagram.expanded.scene13 #body5-img {
            opacity: 0 !important;
        }

        /* Hide original body when limited images are showing */
        .body-diagram.limited-active .body-image {
            opacity: 0;
        }

        /* Sense blocks positioned to the right with dotted lines */
        .sense-blocks-container {
            position: absolute;
            top: 50%;
            right: -100px;
            transform: translateY(-50%);
            width: auto;
            height: 240px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .sense-block {
            position: relative;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 4px;
            text-align: left;
            font-size: 0.75rem;
            font-weight: 600;
            color: #ffffff;
            text-transform: lowercase;
            letter-spacing: 0.1em;
            opacity: 0;
            transform: translateX(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .sense-block::before {
            content: '';
            position: absolute;
            right: 100%;
            top: 50%;
            width: 110px;
            height: 0;
            border-top: 2px dotted rgba(255, 255, 255, 0.5);
            transform: translateY(-50%);
        }

        .sense-block.visible {
            opacity: 1;
            transform: translateX(0);
        }

    </style>
</head>
<body>
    <div class="essay-container">

        <!-- ========== SECTION 1 ========== -->
        <section class="section" id="section-1">

            <h3 class="main-thesis">
                It is my general belief that all human motivation has one source: the desire to shorten the gap between who we are (our identity) and how we live (our reality).
            </h3>

            <div class="identity-container">
                <p class="paragraph">
                    The gap exists because our <span class="keyword keyword-identity" data-keyword id="identity-keyword">identity</span> (our mind, soul, spirit) is <strong>infinite</strong> and abstract—you can't touch, taste, smell, see, or hear it. You can only <span class="emphasis">feel</span> it.
                </p>
                <div class="sticky-note" id="identity-note" onclick="this.classList.toggle('revealed')">
                    <div class="sticky-note-heading">identity</div>
                    <div class="sticky-note-content">If there was a mask over my face, my mom would still know who I am in a room filled with people through my actions. Who we are is indescribable, it's invisible, it just… is.</div>
                </div>
            </div>

            <div class="reality-container">
                <p class="paragraph">
                    Meanwhile, our <span class="keyword keyword-reality" data-keyword id="reality-keyword">reality</span> (where we spend our time, our stuff, our physical body and space) is <strong>finite</strong>: we can directly touch, taste, smell, see, and hear it.
                </p>
                <div class="sticky-note" id="reality-note" onclick="this.classList.toggle('revealed')">
                    <div class="sticky-note-heading">reality</div>
                    <div class="sticky-note-content">I see the decor I hang on my wall, I can specifically show you what I do for my job, I can smell the salmon I'm cooking in the oven, I recognize my own face in the mirror, etc. These aren't concepts or feelings, our reality is observable fact.</div>
                </div>
            </div>

            <p class="paragraph">
                Because our lived reality is finite and <span class="keyword keyword-gap" data-keyword id="limited-keyword">limited</span> by nature, we simply can never capture the <span class="keyword keyword-gap" data-keyword id="infinite-keyword">infinite</span> totality of who we are in our daily lives. Our <span class="keyword keyword-gap" data-keyword id="mind-keyword">mind</span> receives signals that help inform us of our identity as we live our lives, though an <span class="tooltip-trigger highlight">abstract and encrypted<span class="tooltip-content">A blind man cannot directly perceive sight- it exists outside his physical abilities. Instead, sight must be translated into what is accessible: like touch or sound. "The apple is round and smooth." "Red feels like the sun's warmth." These descriptions act as bridges, but they never produce a true visual mental model. Core aspects of sight (like color) remain directly unreachable.<br><br>This mirrors how our minds receive information about who we are. Identity is not directly observable to us. It is only inferred through signals that surface in our various experiences (emotions, desires, affinities, discomforts) which are translated from the constraints of our biological abilities (sight, smell, touch, taste, sound). <span class="red-bold">There is no sixth sense for soul detection.</span><br><br>Just as the blind man cannot see the vase yet can feel its form, texture, and resonance (and from that, still feel alignment with it), we sense our deeper self through indirect articulations. These moments of resonance are not full comprehension, but they are the closest approximation available within a finite body.<span class="tooltip-audio-controls" onclick="event.stopPropagation()"><select class="tooltip-voice-select" id="tooltip-voice-select"></select><button class="tooltip-speed-btn" id="tooltip-speed-btn" onclick="cycleSpeed(this)">1x</button><button class="tooltip-audio-btn" id="tooltip-audio-btn" onclick="toggleTooltipAudio(this)"><svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg></button></span></span></span> modality.
            </p>

            <p class="paragraph">
                The discomfort of living in a reality that doesn't fully reflect who we are is the source of human motivation. We are motivated to reduce this <span class="keyword keyword-gap" data-keyword id="gap-keyword">gap</span>. The more our reality captures our true identity, the more that discomfort fades. This is the core driver behind everything we <span class="keyword keyword-gap" data-keyword id="do-keyword">do</span>:
            </p>

            <div class="body-diagram-container">
                <div class="body-diagram" id="body-diagram">
                    <img src="Human_body_outline.png" alt="Human body outline" class="body-image">
                <!-- Limited sequence images -->
                <img src="body1.png" alt="Body state 1" class="limited-body-image" id="body1-img">
                <img src="body2.png" alt="Body state 2" class="limited-body-image" id="body2-img">
                <img src="body3.png" alt="Body state 3" class="limited-body-image" id="body3-img">
                <img src="body4.png" alt="Body state 4" class="limited-body-image" id="body4-img">
                <img src="body5.png" alt="Body state 5" class="limited-body-image" id="body5-img">
                <div class="sense-blocks-container" id="sense-blocks">
                    <div class="sense-block" data-sense="1">see</div>
                    <div class="sense-block" data-sense="2">hear</div>
                    <div class="sense-block" data-sense="3">smell</div>
                    <div class="sense-block" data-sense="4">taste</div>
                    <div class="sense-block" data-sense="5">touch</div>
                </div>
                <svg class="infinity-bubble" viewBox="0 0 400 500" preserveAspectRatio="none">
                    <defs>
                        <!-- Mask to cut out body shape for orange flash -->
                        <mask id="body-cutout-mask">
                            <!-- White = visible, Black = hidden -->
                            <path fill="white" d="M200,20
                                C320,20 380,80 380,200
                                C380,320 340,400 280,450
                                C240,480 160,480 120,450
                                C60,400 20,320 20,200
                                C20,80 80,20 200,20" />
                            <!-- Cut out body shape (approximate) -->
                            <ellipse cx="200" cy="250" rx="70" ry="180" fill="black" />
                        </mask>
                    </defs>
                    <!-- Faint green fill (full, including body) - shows when revealed -->
                    <path class="bubble-fill-green" d="M200,20
                        C320,20 380,80 380,200
                        C380,320 340,400 280,450
                        C240,480 160,480 120,450
                        C60,400 20,320 20,200
                        C20,80 80,20 200,20" />
                    <!-- Green flash fill - entire circle -->
                    <path class="bubble-fill-flash" d="M200,20
                        C320,20 380,80 380,200
                        C380,320 340,400 280,450
                        C240,480 160,480 120,450
                        C60,400 20,320 20,200
                        C20,80 80,20 200,20" />
                    <path class="bubble-path" d="M200,20
                        C320,20 380,80 380,200
                        C380,320 340,400 280,450
                        C240,480 160,480 120,450
                        C60,400 20,320 20,200
                        C20,80 80,20 200,20" />
                    <!-- Arrows indicating infinity -->
                    <g class="infinity-arrows">
                        <path class="arrow" d="M200,5 L200,-15 M195,-10 L200,-15 L205,-10" />
                        <path class="arrow" d="M395,200 L415,200 M410,195 L415,200 L410,205" />
                        <path class="arrow" d="M200,495 L200,515 M195,510 L200,515 L205,510" />
                        <path class="arrow" d="M5,200 L-15,200 M-10,195 L-15,200 L-10,205" />
                        <path class="arrow" d="M340,80 L355,65 M355,72 L355,65 L348,65" />
                        <path class="arrow" d="M340,420 L355,435 M348,435 L355,435 L355,428" />
                        <path class="arrow" d="M60,420 L45,435 M52,435 L45,435 L45,428" />
                        <path class="arrow" d="M60,80 L45,65 M45,72 L45,65 L52,65" />
                    </g>
                </svg>
                <div class="orb-text">A person is struggling with feeling like the way they perceive, think, and relate is fundamentally different from others, yet lack the language to explain how or why. This creates a distinct discomfort: living in a reality that does not reflect how they operate, even at the level of articulating their own experience.</div>
                <img src="do-scene2.png" alt="Scene 2" class="do-scene2-image">
                <img src="do-scene3.png" alt="Scene 3" class="do-scene3-image">
                <div class="head-orb"></div>
                <div class="scene2-orb orb-blue" data-orb="1"></div>
                <div class="scene2-orb orb-purple" data-orb="2"></div>
                <div class="scene2-orb orb-pink" data-orb="3"></div>
                <div class="scene2-orb orb-red" data-orb="4"></div>
                <div class="scene2-orb orb-orange" data-orb="5"></div>
                <div class="scene2-orb orb-yellow" data-orb="6"></div>
                <div class="scene2-orb orb-cyan" data-orb="7"></div>
                <div class="scene2-orb orb-white" data-orb="8"></div>
                <div class="scene3-orb orb-green" data-orb="1"></div>
                <div class="scene3-orb orb-green" data-orb="2"></div>
                <img src="do-scene4.png" alt="Scene 4" class="do-scene4-image">
                <div class="scene4-orb" data-orb="1"></div>
                <img src="bodyfill1.png" alt="Body Fill" class="body-fill-overlay">
                <div class="scene6-text">Or think about when you were a kid and felt this drive to redecorate your room. One year princesses and pink, the next punk rock brutalism. Why? Functionally the room is the same - desk, chair, bed. But (whether consciously or unconsciously) we felt that discomfort with our space not matching who we are. A drive to match our reality with our identity. And thus, bits of who we are ends up in the posters lining the walls.</div>
                <div class="scene12-text">We go to school, we read, we have deep conversations and experiences… Each piece of knowledge and experience teaching us how to articulate the world around us and subsequently who we are within it: bits of ourselves surface when we find language that perfectly describes part of who we are, maybe it's a personality type, sexuality, a moral or political framework.</div>
                <div class="scene13-text">We chase that ineffable "yes" feeling at concerts, festivals, museums…. Think about the last time you were belting out your favorite song in the car - a bit of your soul is captured in that song and channeled into that chorus.</div>
                <img src="room.png" alt="Room" class="room-image">
                <img src="room1.png" alt="Room 1" class="room1-image">
                <img src="room2.png" alt="Room 2" class="room2-image">
                <img src="room3.png" alt="Room 3" class="room3-image">
                <img src="room4.png" alt="Room 4" class="room4-image">
                <img src="room5.png" alt="Room 5" class="room5-image">
                <img src="read1.png" alt="Read 1" class="slide-image slide-read1">
                <img src="read2.png" alt="Read 2" class="slide-image slide-read2">
                <img src="school1.png" alt="School 1" class="slide-image slide-school1">
                <img src="school2.png" alt="School 2" class="slide-image slide-school2">
                <img src="conversation1.png" alt="Conversation 1" class="slide-image slide-conversation1">
                <img src="conversation2.png" alt="Conversation 2" class="slide-image slide-conversation2">
                <img src="car.png" alt="Car 1" class="slide-image slide-car1">
                <img src="car2.png" alt="Car 2" class="slide-image slide-car2">
                <div class="room-orb" data-room-orb="1"></div>
                <div class="room-orb" data-room-orb="2"></div>
                <div class="room-orb" data-room-orb="3"></div>
                <div class="room-orb" data-room-orb="4"></div>
                <div class="room-orb" data-room-orb="5"></div>
                <div class="room-orb" data-room-orb="6"></div>
                </div>
            </div>

            <p class="paragraph">
                Tactically, this means we are always looking for pieces of ourselves in the physical world - consciously or subconsciously, directly or indirectly. When we find a bit of ourselves in the world - whether it's in a song, a perfume, an outfit that feels like you - we have successfully channeled a bit more of us into our lived reality. Our world bends a bit more in alignment of our identity.
            </p>

            <p class="paragraph">
                Things, knowledge, relationships, and experiences facilitate this process, acting as vessels that bridge our intangible identity into the finite reality we live in:
            </p>

        </section>

        <!-- ========== SECTION 2: WORDS BOX ========== -->
        <section class="section" id="section-2">
            <div class="shaded-box">
                <h4 class="shaded-box-title">example</h4>
                <div class="diagram-placeholder">
                    <!-- Interactive diagram will go here -->
                </div>

                <p class="paragraph">
                    Imagine there was one word in the english language: happy. I therefore would only be able to express a general feeling of happiness. So much of who I am would be left in my own head. Now imagine there were two words: happy, and very. I could more accurately express a feeling of general happiness then: am I happy or (drumroll please)… <em>very</em> happy? If there was a third word, I could more accurately pull my inner state into my reality through articulate. Today, its estimated that there are no more than ~1,000,000 words in the english language.
                </p>

                <p class="paragraph">
                    My lived reality provides me with 1 million words to articulate myself - that's the hard limit. With those words, I express who I am, what I need, how I'm feeling… but only to the extent that I can using my one million available words. But my soul, my inner state is infinite - there could never be enough words to absolutely capture all that I am. The more words you add, the better I can channel myself in the world through articulation, but infinite can never be reached in a finite way. There will never be a finite number of words that equal infinite. And therefore, who you are in totality is bigger than words can describe. Who you are is bigger than art than the art you create, the clothing you express yourself through, your career, your home, your passions. All these elements of your reality channel bits of you, but ultimately your reality is limited to what you can directly see, taste, smell, touch and hear. And who you are is unlimited, invisible, and felt. You can never fit infinite into a finite jar… You can only collect bits of it.
                </p>
            </div>

            <p class="paragraph">
                So TLDR: the discomfort in the gap between our identity and lived reality is the birth of human motivation. <span class="tooltip-trigger">Everything<span class="tooltip-content">*everything meaning after our survival needs are met. Our primary motivation is food, shelter, reproduction (survival). It could be argued that our core desire to survive exists to spend more time channeling more of ourselves into the world, and reproduce to continue this process after death - but that is more of a philosophical thought experiment than what is intended in this essay which is more philosophy for the purpose of practical implementation. Anyway… Our discussion is assuming these needs are met.</span></span> we do is directly or indirectly, consciously or subconsciously, working to alleviate this unease by shortening the gap between identity and lived reality:
            </p>
        </section>

        <!-- Add more sections below -->

    </div>

    <script>
        // ========== TOOLTIP AUDIO ==========
        let tooltipUtterance = null;
        const voiceSelect = document.getElementById('tooltip-voice-select');
        const speeds = [1, 1.5, 2];
        let currentSpeedIndex = 0;
        let audioCharIndex = 0;
        let isSpeedChange = false;
        const tooltipFullText = "A blind man cannot directly perceive sight — it exists outside his physical abilities. Instead, sight must be translated into what is accessible: like touch or sound. The apple is round and smooth. Red feels like the sun's warmth. These descriptions act as bridges, but they never produce a true visual mental model. Core aspects of sight, like color, remain directly unreachable. This mirrors how our minds receive information about who we are. Identity is not directly observable to us. It is only inferred through signals that surface in our various experiences — emotions, desires, affinities, discomforts — which are translated from the constraints of our biological abilities: sight, smell, touch, taste, sound. There is no sixth sense for soul detection. Just as the blind man cannot see the vase yet can feel its form, texture, and resonance, and from that, still feel alignment with it, we sense our deeper self through indirect articulations. These moments of resonance are not full comprehension, but they are the closest approximation available within a finite body.";

        function speakFromIndex(startIndex) {
            const text = tooltipFullText.substring(startIndex);
            if (!text) return;
            tooltipUtterance = new SpeechSynthesisUtterance(text);
            tooltipUtterance.rate = speeds[currentSpeedIndex];
            const voices = speechSynthesis.getVoices();
            if (voiceSelect.value && voices[voiceSelect.value]) {
                tooltipUtterance.voice = voices[voiceSelect.value];
            }
            tooltipUtterance.onboundary = (e) => {
                audioCharIndex = startIndex + e.charIndex;
            };
            tooltipUtterance.onend = () => {
                if (!isSpeedChange) {
                    document.getElementById('tooltip-audio-btn').classList.remove('playing');
                    audioCharIndex = 0;
                }
                isSpeedChange = false;
            };
            speechSynthesis.speak(tooltipUtterance);
        }

        function cycleSpeed(btn) {
            currentSpeedIndex = (currentSpeedIndex + 1) % speeds.length;
            btn.textContent = speeds[currentSpeedIndex] + 'x';
            if (speechSynthesis.speaking) {
                isSpeedChange = true;
                speechSynthesis.cancel();
                speakFromIndex(audioCharIndex);
            }
        }

        function populateVoices() {
            const voices = speechSynthesis.getVoices();
            voiceSelect.innerHTML = '';
            const preferred = ['Samantha', 'Alex', 'Tom', 'Daniel', 'Karen', 'Google US English', 'Google UK English Female', 'Google UK English Male', 'Fred', 'Moira', 'Tessa', 'Fiona'];
            const english = voices
                .map((v, i) => ({ voice: v, index: i }))
                .filter(v => v.voice.lang.startsWith('en'));
            english.sort((a, b) => {
                const aIdx = preferred.findIndex(p => a.voice.name.includes(p));
                const bIdx = preferred.findIndex(p => b.voice.name.includes(p));
                const aRank = aIdx === -1 ? 999 : aIdx;
                const bRank = bIdx === -1 ? 999 : bIdx;
                return aRank - bRank;
            });
            english.slice(0, 4).forEach((v, i) => {
                const opt = document.createElement('option');
                opt.value = v.index;
                opt.textContent = v.voice.name;
                if (i === 0) opt.selected = true;
                voiceSelect.appendChild(opt);
            });
        }
        populateVoices();
        speechSynthesis.onvoiceschanged = populateVoices;

        function toggleTooltipAudio(btn) {
            if (speechSynthesis.speaking) {
                isSpeedChange = false;
                speechSynthesis.cancel();
                btn.classList.remove('playing');
                audioCharIndex = 0;
                return;
            }
            audioCharIndex = 0;
            btn.classList.add('playing');
            speakFromIndex(0);
        }

        // Stop audio when mouse leaves tooltip trigger
        document.querySelector('.tooltip-trigger.highlight').addEventListener('mouseleave', () => {
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
                document.getElementById('tooltip-audio-btn').classList.remove('playing');
            }
        });

        // ========== INTERACTIVE KEYWORD HOVER EFFECT ==========
        // Keywords follow the mouse when hovered

        const keywords = document.querySelectorAll('[data-keyword]');

        keywords.forEach(keyword => {
            let isHovering = false;
            let rect;

            keyword.addEventListener('mouseenter', (e) => {
                isHovering = true;
                keyword.classList.add('hovering');
                rect = keyword.getBoundingClientRect();
            });

            keyword.addEventListener('mouseleave', () => {
                isHovering = false;
                keyword.classList.remove('hovering');
                keyword.style.setProperty('--hover-x', '0px');
                keyword.style.setProperty('--hover-y', '0px');
            });

            keyword.addEventListener('mousemove', (e) => {
                if (!isHovering) return;

                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                // Calculate offset from center (max 15px movement)
                const maxOffset = 15;
                const offsetX = ((e.clientX - centerX) / rect.width) * maxOffset;
                const offsetY = ((e.clientY - centerY) / rect.height) * maxOffset;

                keyword.style.setProperty('--hover-x', `${offsetX}px`);
                keyword.style.setProperty('--hover-y', `${offsetY}px`);
            });
        });

        // ========== GAP KEYWORD CLICK ANIMATION ==========
        // Click on "gap" to draw arrow to diagram and flash fill

        const gapKeyword = document.getElementById('gap-keyword');
        const bodyDiagram = document.getElementById('body-diagram');
        let arrowSvg = null;

        // ========== SEQUENCE TRACKING ==========
        // Order: limited -> infinite -> mind -> gap -> do
        const sequenceState = {
            limitedTriggered: false,
            infiniteTriggered: false,
            mindTriggered: false,
            gapTriggered: false,
            animationInProgress: false
        };

        // Flash a keyword while triggering
        function flashKeyword(keyword) {
            keyword.classList.add('flashing');
            setTimeout(() => keyword.classList.remove('flashing'), 500);
        }

        // ========== LIMITED KEYWORD ANIMATION ==========
        const limitedKeyword = document.getElementById('limited-keyword');
        const senseBlocks = document.querySelectorAll('.sense-block');
        const senseBlocksContainer = document.getElementById('sense-blocks');
        const body1Img = document.getElementById('body1-img');
        const body2Img = document.getElementById('body2-img');
        const body3Img = document.getElementById('body3-img');
        const body4Img = document.getElementById('body4-img');
        const body5Img = document.getElementById('body5-img');
        const bodyImages = [body1Img, body2Img, body3Img, body4Img, body5Img];
        let limitedArrowSvg = null;

        // Duration of limited animation
        const limitedDuration = 500 * 5; // cadence * 5 steps

        function triggerLimited(isAutomatic = false) {
            flashKeyword(limitedKeyword);

            // Add grow animation if auto-triggered - stay big during animation
            if (isAutomatic) {
                limitedKeyword.classList.remove('auto-trigger', 'auto-trigger-shrink');
                void limitedKeyword.offsetWidth; // Force reflow
                limitedKeyword.classList.add('auto-trigger');

                // Shrink back when animation completes
                setTimeout(() => {
                    limitedKeyword.classList.remove('auto-trigger');
                    limitedKeyword.classList.add('auto-trigger-shrink');
                    setTimeout(() => limitedKeyword.classList.remove('auto-trigger-shrink'), 300);
                }, limitedDuration);
            }

            // Remove any existing arrow
            if (limitedArrowSvg) {
                limitedArrowSvg.remove();
            }

            // Reset images and sense blocks
            bodyImages.forEach(img => img.classList.remove('visible'));
            senseBlocks.forEach(block => block.classList.remove('visible'));

            // Hide original body
            bodyDiagram.classList.add('limited-active');

            // Get positions for arrow with scroll offset
            const keywordRect = limitedKeyword.getBoundingClientRect();
            const containerRect = senseBlocksContainer.getBoundingClientRect();
            const scrollX = window.scrollX;
            const scrollY = window.scrollY;

            // Start point: bottom center of "limited" keyword
            const startX = keywordRect.left + keywordRect.width / 2 + scrollX;
            const startY = keywordRect.bottom + 5 + scrollY;

            // End point: left side of sense blocks container
            const endX = containerRect.left - 10 + scrollX;
            const endY = containerRect.top + containerRect.height / 2 + scrollY;

            // Create SVG for the arrow
            limitedArrowSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            limitedArrowSvg.classList.add('gap-arrow-svg');
            limitedArrowSvg.style.width = document.documentElement.scrollWidth + 'px';
            limitedArrowSvg.style.height = document.documentElement.scrollHeight + 'px';
            limitedArrowSvg.setAttribute('viewBox', `0 0 ${document.documentElement.scrollWidth} ${document.documentElement.scrollHeight}`);

            // Create curved path
            const midY = (startY + endY) / 2;
            const pathD = `M ${startX} ${startY} Q ${endX - 50} ${midY}, ${endX} ${endY}`;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.classList.add('gap-arrow-line');
            path.setAttribute('d', pathD);

            // Create arrow head pointing right
            const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            arrowHead.classList.add('gap-arrow-head');
            arrowHead.setAttribute('points', `${endX + 5},${endY} ${endX - 8},${endY - 6} ${endX - 8},${endY + 6}`);

            limitedArrowSvg.appendChild(path);
            limitedArrowSvg.appendChild(arrowHead);
            document.body.appendChild(limitedArrowSvg);

            // Trigger arrow animation
            requestAnimationFrame(() => {
                path.classList.add('animating');
                arrowHead.classList.add('animating');
            });

            // Force reflow then start sequence
            void senseBlocks[4].offsetWidth;

            // Cadence timing
            const cadence = 500;

            // body1 + "touch" (bottom first) - immediate
            body1Img.classList.add('visible');
            senseBlocks[4].classList.add('visible'); // touch

            // body2 + "taste"
            setTimeout(() => {
                body2Img.classList.add('visible');
                senseBlocks[3].classList.add('visible'); // taste
            }, cadence);

            // body3 + "smell"
            setTimeout(() => {
                body3Img.classList.add('visible');
                senseBlocks[2].classList.add('visible'); // smell
            }, cadence * 2);

            // body4 + "hear"
            setTimeout(() => {
                body4Img.classList.add('visible');
                senseBlocks[1].classList.add('visible'); // hear
            }, cadence * 3);

            // body5 + "see"
            setTimeout(() => {
                body5Img.classList.add('visible');
                senseBlocks[0].classList.add('visible'); // see
            }, cadence * 4);

            // Remove arrow after animation completes
            setTimeout(() => {
                if (limitedArrowSvg) {
                    limitedArrowSvg.style.opacity = '0';
                    limitedArrowSvg.style.transition = 'opacity 0.5s ease';
                    setTimeout(() => {
                        if (limitedArrowSvg) {
                            limitedArrowSvg.remove();
                            limitedArrowSvg = null;
                        }
                    }, 500);
                }
            }, limitedDuration);

            sequenceState.limitedTriggered = true;
        }

        limitedKeyword.addEventListener('click', (e) => {
            e.stopPropagation();
            sequenceState.animationInProgress = true;
            triggerLimited(false);
            // Clear flag after limited animation completes
            setTimeout(() => {
                sequenceState.animationInProgress = false;
            }, limitedDuration + 500);
        });

        // ========== IDENTITY KEYWORD CLICK ANIMATION ==========
        // Click on "identity" to draw arrow to sticky note and reveal it

        const identityKeyword = document.getElementById('identity-keyword');
        const identityNote = document.getElementById('identity-note');
        let identityArrowSvg = null;

        identityKeyword.addEventListener('click', (e) => {
            e.stopPropagation();

            // If already revealed, just close it
            if (identityNote.classList.contains('revealed')) {
                identityNote.classList.remove('revealed');
                return;
            }

            // Remove any existing arrow
            if (identityArrowSvg) {
                identityArrowSvg.remove();
            }

            // Get positions with scroll offset for absolute positioning
            const keywordRect = identityKeyword.getBoundingClientRect();
            const noteRect = identityNote.getBoundingClientRect();
            const scrollX = window.scrollX;
            const scrollY = window.scrollY;

            // Start point: right side of keyword
            const startX = keywordRect.right + 5 + scrollX;
            const startY = keywordRect.top + keywordRect.height / 2 + scrollY;

            // End point: left side of sticky note
            const endX = noteRect.left - 5 + scrollX;
            const endY = noteRect.top + noteRect.height / 2 + scrollY;

            // Create SVG for the arrow
            identityArrowSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            identityArrowSvg.classList.add('gap-arrow-svg');
            identityArrowSvg.style.width = document.documentElement.scrollWidth + 'px';
            identityArrowSvg.style.height = document.documentElement.scrollHeight + 'px';
            identityArrowSvg.setAttribute('viewBox', `0 0 ${document.documentElement.scrollWidth} ${document.documentElement.scrollHeight}`);

            // Create curved path
            const midX = (startX + endX) / 2;
            const pathD = `M ${startX} ${startY} Q ${midX} ${startY - 30}, ${endX} ${endY}`;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.classList.add('gap-arrow-line');
            path.setAttribute('d', pathD);
            path.style.stroke = '#60a5fa'; // Blue for identity

            // Create arrow head pointing right
            const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            arrowHead.classList.add('gap-arrow-head');
            arrowHead.setAttribute('points', `${endX + 5},${endY} ${endX - 8},${endY - 6} ${endX - 8},${endY + 6}`);
            arrowHead.style.fill = '#60a5fa'; // Blue for identity

            identityArrowSvg.appendChild(path);
            identityArrowSvg.appendChild(arrowHead);
            document.body.appendChild(identityArrowSvg);

            // Trigger animation
            requestAnimationFrame(() => {
                path.classList.add('animating');
                arrowHead.classList.add('animating');
            });

            // Reveal the sticky note after arrow reaches
            setTimeout(() => {
                identityNote.classList.add('revealed');

                // Remove arrow after a delay
                setTimeout(() => {
                    if (identityArrowSvg) {
                        identityArrowSvg.style.opacity = '0';
                        identityArrowSvg.style.transition = 'opacity 0.5s ease';
                        setTimeout(() => {
                            identityArrowSvg.remove();
                            identityArrowSvg = null;
                        }, 500);
                    }
                }, 1500);
            }, 600);
        });

        // ========== INFINITE KEYWORD CLICK ANIMATION ==========
        // Click on "infinite" to draw arrow to orb and reveal it

        const infiniteKeyword = document.getElementById('infinite-keyword');
        let infiniteArrowSvg = null;

        // Duration of infinite animation
        const infiniteDuration = 2600; // arrow + reveal + cleanup

        function triggerInfinite(isAutomatic = false) {
            flashKeyword(infiniteKeyword);

            // Add grow animation if auto-triggered
            if (isAutomatic) {
                infiniteKeyword.classList.remove('auto-trigger', 'auto-trigger-shrink');
                void infiniteKeyword.offsetWidth;
                infiniteKeyword.classList.add('auto-trigger');

                setTimeout(() => {
                    infiniteKeyword.classList.remove('auto-trigger');
                    infiniteKeyword.classList.add('auto-trigger-shrink');
                    setTimeout(() => infiniteKeyword.classList.remove('auto-trigger-shrink'), 300);
                }, 600);
            }

            sequenceState.infiniteTriggered = true;
        }

        infiniteKeyword.addEventListener('click', (e) => {
            e.stopPropagation();
            sequenceState.animationInProgress = true;

            // Check if limited needs to be triggered first
            if (!sequenceState.limitedTriggered) {
                triggerLimited(true);
                setTimeout(() => {
                    triggerInfinite(false);
                    setTimeout(() => {
                        sequenceState.animationInProgress = false;
                    }, 800);
                }, limitedDuration + 200);
            } else {
                triggerInfinite(false);
                setTimeout(() => {
                    sequenceState.animationInProgress = false;
                }, 800);
            }
        });

        // ========== MIND KEYWORD CLICK ANIMATION ==========
        // Click on "mind" to draw arrow to orb and reveal it
        const mindKeyword = document.getElementById('mind-keyword');
        let mindArrowSvg = null;

        const mindDuration = 2600; // same as infinite

        function triggerMind(isAutomatic = false) {
            flashKeyword(mindKeyword);

            // Add grow animation if auto-triggered
            if (isAutomatic) {
                mindKeyword.classList.remove('auto-trigger', 'auto-trigger-shrink');
                void mindKeyword.offsetWidth;
                mindKeyword.classList.add('auto-trigger');

                setTimeout(() => {
                    mindKeyword.classList.remove('auto-trigger');
                    mindKeyword.classList.add('auto-trigger-shrink');
                    setTimeout(() => mindKeyword.classList.remove('auto-trigger-shrink'), 300);
                }, mindDuration);
            }

            // Remove any existing arrow
            if (mindArrowSvg) {
                mindArrowSvg.remove();
            }

            // Get positions with scroll offset
            const keywordRect = mindKeyword.getBoundingClientRect();
            const diagramRect = bodyDiagram.getBoundingClientRect();
            const scrollX = window.scrollX;
            const scrollY = window.scrollY;

            // Start point: bottom center of keyword
            const startX = keywordRect.left + keywordRect.width / 2 + scrollX;
            const startY = keywordRect.bottom + 5 + scrollY;

            // End point: top edge of orb (outside)
            const endX = diagramRect.left + diagramRect.width / 2 + scrollX;
            const endY = diagramRect.top - 10 + scrollY;

            // Create SVG for the arrow
            mindArrowSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            mindArrowSvg.classList.add('gap-arrow-svg');
            mindArrowSvg.style.width = document.documentElement.scrollWidth + 'px';
            mindArrowSvg.style.height = document.documentElement.scrollHeight + 'px';
            mindArrowSvg.setAttribute('viewBox', `0 0 ${document.documentElement.scrollWidth} ${document.documentElement.scrollHeight}`);

            // Create curved path
            const midY = (startY + endY) / 2;
            const pathD = `M ${startX} ${startY} Q ${startX} ${midY}, ${endX} ${endY}`;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.classList.add('gap-arrow-line');
            path.setAttribute('d', pathD);

            // Create arrow head pointing down
            const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            arrowHead.classList.add('gap-arrow-head');
            arrowHead.setAttribute('points', `${endX},${endY + 5} ${endX - 8},${endY - 8} ${endX + 8},${endY - 8}`);

            mindArrowSvg.appendChild(path);
            mindArrowSvg.appendChild(arrowHead);
            document.body.appendChild(mindArrowSvg);

            // Trigger animation
            requestAnimationFrame(() => {
                path.classList.add('animating');
                arrowHead.classList.add('animating');
            });

            // Reveal the orb after arrow reaches
            setTimeout(() => {
                if (!bodyDiagram.classList.contains('revealed')) {
                    bodyDiagram.classList.add('revealed');
                    updateOrbPosition('infinite');
                }

                // Remove arrow after a delay
                setTimeout(() => {
                    if (mindArrowSvg) {
                        mindArrowSvg.style.opacity = '0';
                        mindArrowSvg.style.transition = 'opacity 0.5s ease';
                        setTimeout(() => {
                            if (mindArrowSvg) {
                                mindArrowSvg.remove();
                                mindArrowSvg = null;
                            }
                        }, 500);
                    }
                }, 1500);
            }, 600);

            sequenceState.mindTriggered = true;
        }

        mindKeyword.addEventListener('click', (e) => {
            e.stopPropagation();
            sequenceState.animationInProgress = true;

            // Check sequence: need limited and infinite first
            if (!sequenceState.limitedTriggered && !sequenceState.infiniteTriggered) {
                triggerLimited(true);
                setTimeout(() => {
                    triggerInfinite(true);
                    setTimeout(() => {
                        triggerMind(false);
                        setTimeout(() => {
                            sequenceState.animationInProgress = false;
                        }, mindDuration + 500);
                    }, infiniteDuration + 200);
                }, limitedDuration + 200);
            } else if (!sequenceState.infiniteTriggered) {
                triggerInfinite(true);
                setTimeout(() => {
                    triggerMind(false);
                    setTimeout(() => {
                        sequenceState.animationInProgress = false;
                    }, mindDuration + 500);
                }, infiniteDuration + 200);
            } else {
                triggerMind(false);
                setTimeout(() => {
                    sequenceState.animationInProgress = false;
                }, mindDuration + 500);
            }
        });

        // ========== GAP TRIGGER FUNCTION ==========
        function triggerGap(isAutomatic = false) {
            flashKeyword(gapKeyword);

            // Add grow animation if auto-triggered
            if (isAutomatic) {
                gapKeyword.classList.remove('auto-trigger', 'auto-trigger-shrink');
                void gapKeyword.offsetWidth; // Force reflow
                gapKeyword.classList.add('auto-trigger');

                // Shrink back after animation
                setTimeout(() => {
                    gapKeyword.classList.remove('auto-trigger');
                    gapKeyword.classList.add('auto-trigger-shrink');
                    setTimeout(() => gapKeyword.classList.remove('auto-trigger-shrink'), 300);
                }, 2500);
            }

            // Remove any existing arrow
            if (arrowSvg) {
                arrowSvg.remove();
            }

            // Get positions with scroll offset
            const gapRect = gapKeyword.getBoundingClientRect();
            const diagramRect = bodyDiagram.getBoundingClientRect();
            const scrollX = window.scrollX;
            const scrollY = window.scrollY;

            // Start point: bottom center of "gap" word
            const startX = gapRect.left + gapRect.width / 2 + scrollX;
            const startY = gapRect.bottom + 5 + scrollY;

            // End point: top edge of orb (outside)
            const endX = diagramRect.left + diagramRect.width / 2 + scrollX;
            const endY = diagramRect.top - 10 + scrollY;

            // Create SVG for the arrow
            arrowSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            arrowSvg.classList.add('gap-arrow-svg');
            arrowSvg.style.width = document.documentElement.scrollWidth + 'px';
            arrowSvg.style.height = document.documentElement.scrollHeight + 'px';
            arrowSvg.setAttribute('viewBox', `0 0 ${document.documentElement.scrollWidth} ${document.documentElement.scrollHeight}`);

            // Create curved path
            const midY = (startY + endY) / 2;
            const pathD = `M ${startX} ${startY} Q ${startX} ${midY}, ${endX} ${endY}`;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.classList.add('gap-arrow-line');
            path.setAttribute('d', pathD);

            // Create arrow head pointing down
            const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            arrowHead.classList.add('gap-arrow-head');
            arrowHead.setAttribute('points', `${endX},${endY + 5} ${endX - 8},${endY - 8} ${endX + 8},${endY - 8}`);

            arrowSvg.appendChild(path);
            arrowSvg.appendChild(arrowHead);
            document.body.appendChild(arrowSvg);

            // Trigger animation
            requestAnimationFrame(() => {
                path.classList.add('animating');
                arrowHead.classList.add('animating');
            });

            // Reveal the bubble if not already revealed
            if (!bodyDiagram.classList.contains('revealed')) {
                bodyDiagram.classList.add('revealed');
            }

            // Flash the fill after arrow reaches
            setTimeout(() => {
                bodyDiagram.classList.add('flash-fill');

                // Remove flash class after animation
                setTimeout(() => {
                    bodyDiagram.classList.remove('flash-fill');
                }, 2000);

                // Remove arrow after a delay
                setTimeout(() => {
                    if (arrowSvg) {
                        arrowSvg.style.opacity = '0';
                        arrowSvg.style.transition = 'opacity 0.5s ease';
                        setTimeout(() => {
                            arrowSvg.remove();
                            arrowSvg = null;
                        }, 500);
                    }
                }, 2200);
            }, 600);

            sequenceState.gapTriggered = true;
        }

        gapKeyword.addEventListener('click', (e) => {
            e.stopPropagation();
            sequenceState.animationInProgress = true;

            // Check sequence: need limited, infinite, and mind first
            if (!sequenceState.limitedTriggered && !sequenceState.infiniteTriggered && !sequenceState.mindTriggered) {
                triggerLimited(true);
                setTimeout(() => {
                    triggerInfinite(true);
                    setTimeout(() => {
                        triggerMind(true);
                        setTimeout(() => {
                            triggerGap(false);
                            setTimeout(() => {
                                sequenceState.animationInProgress = false;
                            }, 3000);
                        }, mindDuration + 200);
                    }, infiniteDuration + 200);
                }, limitedDuration + 200);
            } else if (!sequenceState.infiniteTriggered && !sequenceState.mindTriggered) {
                triggerInfinite(true);
                setTimeout(() => {
                    triggerMind(true);
                    setTimeout(() => {
                        triggerGap(false);
                        setTimeout(() => {
                            sequenceState.animationInProgress = false;
                        }, 3000);
                    }, mindDuration + 200);
                }, infiniteDuration + 200);
            } else if (!sequenceState.mindTriggered) {
                triggerMind(true);
                setTimeout(() => {
                    triggerGap(false);
                    setTimeout(() => {
                        sequenceState.animationInProgress = false;
                    }, 3000);
                }, mindDuration + 200);
            } else {
                triggerGap(false);
                setTimeout(() => {
                    sequenceState.animationInProgress = false;
                }, 3000);
            }
        });

        // ========== DEBUG MODE FOR ORB POSITIONING ==========
        // Set to true to click and get coordinates, false for normal use
        const DEBUG_ORB_POSITIONS = false;
        const DEBUG_SCENE = 'scene4'; // which scene to debug: 'infinite', 'scene1', 'scene2', 'scene3', 'scene4'
        let debugOrbNumber = 1; // for scene2 (1-8) or scene3 (1-2), which orb we're positioning

        const headOrb = document.querySelector('.head-orb');

        // Orb positions as percentages of the body-diagram container
        const orbPositions = {
            infinite: { x: 52.5, y: 16.9 },  // body head when infinite clicked (before do)
            scene1: { x: 50.8, y: 55.5 },    // body head position (do clicked)
            scene2: { x: 54.1, y: 47.1 },    // computer person head position (green orb)
            scene3: { x: 50, y: 50 },        // scene 3 head position (not used - scene3 has its own orbs)
            scene4: { x: 50.8, y: 55.5 }     // same as scene1 - body in same position
        };

        // Scene 2 colored orb positions
        const scene2OrbPositions = {
            1: { x: 41.1, y: 54.7 },   // blue
            2: { x: 41.0, y: 63.2 },   // purple
            3: { x: 33.4, y: 59.6 },   // pink
            4: { x: 33.3, y: 62.2 },   // red
            5: { x: 29.0, y: 64.9 },   // orange
            6: { x: 29.7, y: 61.3 },   // yellow
            7: { x: 24.8, y: 63.8 },   // cyan
            8: { x: 25.8, y: 60.9 }    // white
        };

        const scene2Orbs = document.querySelectorAll('.scene2-orb');
        const scene3Orbs = document.querySelectorAll('.scene3-orb');

        // Scene 3 green orb positions
        const scene3OrbPositions = {
            1: { x: 58.3, y: 56.8 },   // green orb 1
            2: { x: 31.9, y: 43.9 }    // green orb 2
        };

        // Scene 4 orb position (for the graphic)
        const scene4OrbPositions = {
            1: { x: 68.0, y: 70.2 }
        };

        const scene4Orbs = document.querySelectorAll('.scene4-orb');

        // Path debug mode disabled - waypoints captured

        // ========== ROOM ORB POSITIONS ==========
        // Orb 1: appears in scene7, persists through scene10
        // Orb 2: appears in scene8, persists through scene10
        // Orb 3: appears in scene9, persists through scene10
        // Orb 4: appears in scene9, persists through scene10
        // Orb 5: appears in scene10
        const roomOrbPositions = {
            1: { x: 29.5, y: 48.3 },  // room1/scene7
            2: { x: 70.2, y: 48.4 },  // room2/scene8
            3: { x: 56.3, y: 46.4 },  // room3/scene9
            4: { x: 80.0, y: 44.9 },  // room3/scene9
            5: { x: 43.4, y: 47.6 },  // room4/scene10
            6: { x: 50.2, y: 59.7 }   // head orb - all scenes
        };

        const roomOrbs = document.querySelectorAll('.room-orb');

        function updateRoomOrbs() {
            roomOrbs.forEach(orb => {
                const orbNum = orb.dataset.roomOrb;
                const pos = roomOrbPositions[orbNum];
                if (pos) {
                    orb.style.left = pos.x + '%';
                    orb.style.top = pos.y + '%';
                }
            });
        }

        // ========== CLICK DESTINATION DEBUG MODE ==========
        // Click anywhere on the body diagram to get destination coordinates
        const DEBUG_DESTINATION = false;

        if (DEBUG_DESTINATION) {
            const destDebugPanel = document.createElement('div');
            destDebugPanel.style.cssText = 'position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.9); color: #86efac; padding: 15px; border-radius: 8px; font-family: monospace; font-size: 14px; z-index: 9999; min-width: 280px;';
            destDebugPanel.innerHTML = `<strong>CLICK DEBUG</strong><br><br>Click anywhere to get coordinates.<br>A marker will appear where you click.<br><br><div id="click-coords" style="color: #fef08a; font-size: 16px;">Click to get coords...</div>`;
            document.body.appendChild(destDebugPanel);

            // Create a marker element
            const marker = document.createElement('div');
            marker.style.cssText = 'position: absolute; width: 20px; height: 20px; background: red; border-radius: 50%; z-index: 9999; display: none; transform: translate(-50%, -50%); pointer-events: none;';
            bodyDiagram.appendChild(marker);

            bodyDiagram.addEventListener('click', (e) => {
                const rect = bodyDiagram.getBoundingClientRect();
                const x = ((e.clientX - rect.left) / rect.width * 100).toFixed(1);
                const y = ((e.clientY - rect.top) / rect.height * 100).toFixed(1);

                // Show marker at click position
                marker.style.display = 'block';
                marker.style.left = x + '%';
                marker.style.top = y + '%';

                document.getElementById('click-coords').innerHTML = `<strong>x: ${x}, y: ${y}</strong>`;
                console.log(`Destination: { x: ${x}, y: ${y} }`);
            }, true);
        }

        // ========== ROOM ORB DEBUG MODE ==========
        const DEBUG_ROOM_ORBS = false;
        const DEBUG_ROOM_SCENE = 'scene6'; // 'scene6', 'scene7', 'scene8', 'scene9', 'scene10'
        let debugRoomOrbNumber = 6; // which orb to position (1-6, 6=head)

        if (DEBUG_ROOM_ORBS) {
            // Add CSS to make room orbs draggable
            const roomDebugStyle = document.createElement('style');
            roomDebugStyle.textContent = `
                .room-orb {
                    cursor: grab !important;
                    pointer-events: auto !important;
                }
            `;
            document.head.appendChild(roomDebugStyle);

            // Create debug panel
            const roomDebugPanel = document.createElement('div');
            roomDebugPanel.style.cssText = 'position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.9); color: #86efac; padding: 15px; border-radius: 8px; font-family: monospace; font-size: 12px; z-index: 9999; min-width: 300px;';
            roomDebugPanel.innerHTML = `<strong>ROOM ORB DEBUG</strong><br>Scene: ${DEBUG_ROOM_SCENE}<br>Orb #: ${debugRoomOrbNumber} (HEAD)<br><br>Click to position orb.<br>Press 1-6 to switch (6=head).<br><br><div id="room-orb-coords">Click to get coords</div>`;
            document.body.appendChild(roomDebugPanel);

            bodyDiagram.addEventListener('click', (e) => {
                const currentScene = DEBUG_ROOM_SCENE;
                if (!bodyDiagram.classList.contains(currentScene)) return;

                const rect = bodyDiagram.getBoundingClientRect();
                const x = ((e.clientX - rect.left) / rect.width * 100).toFixed(1);
                const y = ((e.clientY - rect.top) / rect.height * 100).toFixed(1);

                // Position the current debug orb
                const orb = document.querySelector(`.room-orb[data-room-orb="${debugRoomOrbNumber}"]`);
                if (orb) {
                    orb.style.left = x + '%';
                    orb.style.top = y + '%';
                    orb.style.opacity = '1';
                }

                document.getElementById('room-orb-coords').innerHTML = `Orb ${debugRoomOrbNumber}: { x: ${x}, y: ${y} }`;
                console.log(`${debugRoomOrbNumber}: { x: ${x}, y: ${y} }`);
            }, true);

            document.addEventListener('keydown', (e) => {
                if (e.key >= '1' && e.key <= '6') {
                    debugRoomOrbNumber = parseInt(e.key);
                    roomDebugPanel.innerHTML = `<strong>ROOM ORB DEBUG</strong><br>Scene: ${DEBUG_ROOM_SCENE}<br>Orb #: ${debugRoomOrbNumber} ${debugRoomOrbNumber === 6 ? '(HEAD)' : ''}<br><br>Click to position orb.<br>Press 1-6 to switch (6=head).<br><br><div id="room-orb-coords">Click to get coords</div>`;
                }
            });
        }

        function updateScene4Orbs() {
            scene4Orbs.forEach(orb => {
                const orbNum = orb.dataset.orb;
                const pos = scene4OrbPositions[orbNum];
                if (pos) {
                    orb.style.left = pos.x + '%';
                    orb.style.top = pos.y + '%';
                }
            });
        }

        function updateOrbPosition(scene) {
            const pos = orbPositions[scene];
            if (pos && headOrb) {
                headOrb.style.left = pos.x + '%';
                headOrb.style.top = pos.y + '%';
            }
        }

        function updateScene2Orbs() {
            scene2Orbs.forEach(orb => {
                const orbNum = orb.dataset.orb;
                const pos = scene2OrbPositions[orbNum];
                if (pos) {
                    orb.style.left = pos.x + '%';
                    orb.style.top = pos.y + '%';
                }
            });
        }

        function updateScene3Orbs() {
            scene3Orbs.forEach(orb => {
                const orbNum = orb.dataset.orb;
                const pos = scene3OrbPositions[orbNum];
                if (pos) {
                    orb.style.left = pos.x + '%';
                    orb.style.top = pos.y + '%';
                }
            });
        }

        // ========== BODY DIAGRAM CLICK TO RESET OR ADVANCE SCENE ==========
        const orbText = document.querySelector('.orb-text');
        const scene1Text = "A person is struggling with feeling like the way they perceive, think, and relate is fundamentally different from others, yet lack the language to explain how or why. This creates a distinct discomfort: living in a reality that does not reflect how they operate, even at the level of articulating their own experience.";
        const scene2Text = "That discomfort drives him to search for an explanation.";
        const scene3Text = "When the person receives a diagnosis of autism, nothing about their reality changes. They are the same before and after. What changes is alignment. The diagnosis gives language to an otherwise inexpressible identity, making their inner experience legible to themselves and to the world.";
        const scene4Text = "The relief in a diagnosis does not come from correction or cure, but from reducing the gap between identity and reality.";

        // Keyboard navigation - left arrow to go back
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' && bodyDiagram.classList.contains('expanded')) {
                e.preventDefault();
                // Go back to previous scene
                if (bodyDiagram.classList.contains('scene13')) {
                    // Go back through car slides first
                    if (bodyDiagram.classList.contains('slide-2')) {
                        bodyDiagram.classList.remove('slide-2');
                        // Back to default (car1)
                        return;
                    }
                    // Default state (car1), go back to scene12 slide-6
                    bodyDiagram.classList.remove('scene13');
                    bodyDiagram.classList.add('slide-6');
                    return;
                }
                if (bodyDiagram.classList.contains('scene12')) {
                    // Go back through slides first
                    if (bodyDiagram.classList.contains('slide-6')) {
                        bodyDiagram.classList.remove('slide-6');
                        bodyDiagram.classList.add('slide-5');
                        return;
                    }
                    if (bodyDiagram.classList.contains('slide-5')) {
                        bodyDiagram.classList.remove('slide-5');
                        bodyDiagram.classList.add('slide-4');
                        return;
                    }
                    if (bodyDiagram.classList.contains('slide-4')) {
                        bodyDiagram.classList.remove('slide-4');
                        bodyDiagram.classList.add('slide-3');
                        return;
                    }
                    if (bodyDiagram.classList.contains('slide-3')) {
                        bodyDiagram.classList.remove('slide-3');
                        bodyDiagram.classList.add('slide-2');
                        return;
                    }
                    if (bodyDiagram.classList.contains('slide-2')) {
                        bodyDiagram.classList.remove('slide-2');
                        // Back to default (read1)
                        return;
                    }
                    // Default state (read1), go back to scene11
                    bodyDiagram.classList.remove('scene12');
                    return;
                }
                if (bodyDiagram.classList.contains('scene11')) {
                    bodyDiagram.classList.remove('scene11');
                    bodyDiagram.classList.remove('animation-complete');
                    updateRoomOrbs();
                    return;
                }
                if (bodyDiagram.classList.contains('scene10')) {
                    bodyDiagram.classList.remove('scene10');
                    return;
                }
                if (bodyDiagram.classList.contains('scene9')) {
                    bodyDiagram.classList.remove('scene9');
                    return;
                }
                if (bodyDiagram.classList.contains('scene8')) {
                    bodyDiagram.classList.remove('scene8');
                    return;
                }
                if (bodyDiagram.classList.contains('scene7')) {
                    bodyDiagram.classList.remove('scene7');
                    return;
                }
                if (bodyDiagram.classList.contains('scene6')) {
                    bodyDiagram.classList.remove('scene6');
                    return;
                }
                if (bodyDiagram.classList.contains('scene5')) {
                    bodyDiagram.classList.remove('scene5');
                    return;
                }
                if (bodyDiagram.classList.contains('scene4')) {
                    bodyDiagram.classList.remove('scene4');
                    orbText.textContent = scene3Text;
                    return;
                }
                if (bodyDiagram.classList.contains('scene3')) {
                    bodyDiagram.classList.remove('scene3');
                    orbText.textContent = scene2Text;
                    return;
                }
                if (bodyDiagram.classList.contains('scene2')) {
                    bodyDiagram.classList.remove('scene2');
                    orbText.textContent = scene1Text;
                    updateOrbPosition('scene1');
                    return;
                }
            }
        });

        bodyDiagram.addEventListener('click', (e) => {
            // Block clicks during keyword animations
            if (sequenceState.animationInProgress) {
                return;
            }

            // Determine current scene
            let currentScene = null;
            if (bodyDiagram.classList.contains('expanded') && bodyDiagram.classList.contains('scene4')) {
                currentScene = 'scene4';
            } else if (bodyDiagram.classList.contains('expanded') && bodyDiagram.classList.contains('scene3')) {
                currentScene = 'scene3';
            } else if (bodyDiagram.classList.contains('expanded') && bodyDiagram.classList.contains('scene2')) {
                currentScene = 'scene2';
            } else if (bodyDiagram.classList.contains('expanded')) {
                currentScene = 'scene1';
            } else if (bodyDiagram.classList.contains('revealed')) {
                currentScene = 'infinite';
            }

            // DEBUG MODE: Show coordinates where you clicked
            if (DEBUG_ORB_POSITIONS && currentScene === DEBUG_SCENE) {
                const rect = bodyDiagram.getBoundingClientRect();
                const x = ((e.clientX - rect.left) / rect.width * 100).toFixed(1);
                const y = ((e.clientY - rect.top) / rect.height * 100).toFixed(1);

                // For scene2, we're positioning orbs 1-8
                const orbColors = ['', 'blue', 'purple', 'pink', 'red', 'orange', 'yellow', 'cyan', 'white'];

                // Show coordinates on screen
                const coordDisplay = document.createElement('div');
                coordDisplay.style.cssText = 'position:fixed;top:20px;left:50%;transform:translateX(-50%);background:#86efac;color:#000;padding:15px 25px;border-radius:8px;font-family:monospace;font-size:16px;z-index:9999;';

                if (DEBUG_SCENE === 'scene2') {
                    coordDisplay.innerHTML = `<strong>Orb ${debugOrbNumber} (${orbColors[debugOrbNumber]}):</strong> x: ${x}, y: ${y}<br><small>Click again for next orb (${debugOrbNumber + 1}/8)</small>`;

                    // Move this orb to clicked position
                    const currentOrb = document.querySelector(`.scene2-orb[data-orb="${debugOrbNumber}"]`);
                    if (currentOrb) {
                        currentOrb.style.left = x + '%';
                        currentOrb.style.top = y + '%';
                    }

                    console.log(`${debugOrbNumber}: { x: ${x}, y: ${y} },   // ${orbColors[debugOrbNumber]}`);

                    // Move to next orb
                    debugOrbNumber++;
                    if (debugOrbNumber > 8) debugOrbNumber = 1;
                } else if (DEBUG_SCENE === 'scene3') {
                    coordDisplay.innerHTML = `<strong>Green Orb ${debugOrbNumber}:</strong> x: ${x}, y: ${y}<br><small>Click again for next orb (${debugOrbNumber}/2)</small>`;

                    // Move this orb to clicked position
                    const currentOrb = document.querySelector(`.scene3-orb[data-orb="${debugOrbNumber}"]`);
                    if (currentOrb) {
                        currentOrb.style.left = x + '%';
                        currentOrb.style.top = y + '%';
                    }

                    console.log(`${debugOrbNumber}: { x: ${x}, y: ${y} },   // green orb ${debugOrbNumber}`);

                    // Move to next orb
                    debugOrbNumber++;
                    if (debugOrbNumber > 2) debugOrbNumber = 1;
                } else if (DEBUG_SCENE === 'scene4') {
                    coordDisplay.innerHTML = `<strong>Scene 4 Orb:</strong> x: ${x}, y: ${y}<br><small>Orb for the graphic</small>`;

                    // Move this orb to clicked position
                    const currentOrb = document.querySelector(`.scene4-orb[data-orb="1"]`);
                    if (currentOrb) {
                        currentOrb.style.left = x + '%';
                        currentOrb.style.top = y + '%';
                    }

                    console.log(`1: { x: ${x}, y: ${y} },   // scene4 orb`);
                } else {
                    coordDisplay.innerHTML = `<strong>Clicked at (${DEBUG_SCENE}):</strong> x: ${x}, y: ${y}<br><small>Copy these values to orbPositions</small>`;
                    headOrb.style.left = x + '%';
                    headOrb.style.top = y + '%';
                    console.log(`{ x: ${x}, y: ${y} }`);
                }

                // Remove any existing coord display first
                const existingDisplay = document.querySelector('.coord-display');
                if (existingDisplay) existingDisplay.remove();

                coordDisplay.classList.add('coord-display');
                document.body.appendChild(coordDisplay);

                // Display stays until next click (removed when new one is created)

                return;
            }

            // If expanded but no scene yet (initial state), ignore clicks
            if (bodyDiagram.classList.contains('expanded') && !bodyDiagram.classList.contains('scene2') && !bodyDiagram.classList.contains('scene3') && !bodyDiagram.classList.contains('scene4') && !bodyDiagram.classList.contains('scene5') && !bodyDiagram.classList.contains('scene6') && !bodyDiagram.classList.contains('scene7') && !bodyDiagram.classList.contains('scene8') && !bodyDiagram.classList.contains('scene9') && !bodyDiagram.classList.contains('scene10') && !bodyDiagram.classList.contains('scene11') && !bodyDiagram.classList.contains('scene12') && !bodyDiagram.classList.contains('scene13')) {
                // Don't trigger anything before the first text scene
                return;
            }

            // If scene2 but not scene3, advance to scene3
            if (bodyDiagram.classList.contains('expanded') && bodyDiagram.classList.contains('scene2') && !bodyDiagram.classList.contains('scene3')) {
                bodyDiagram.classList.remove('scene2');
                bodyDiagram.classList.add('scene3');
                orbText.textContent = scene3Text;
                updateScene3Orbs();
                return;
            }

            // If scene3 but not scene4, advance to scene4
            if (bodyDiagram.classList.contains('expanded') && bodyDiagram.classList.contains('scene3') && !bodyDiagram.classList.contains('scene4')) {
                bodyDiagram.classList.remove('scene3');
                bodyDiagram.classList.add('scene4');
                orbText.textContent = scene4Text;
                updateOrbPosition('scene4');
                updateScene4Orbs();
                return;
            }

            // If scene4, advance to scene5 (orb travels along path)
            if (bodyDiagram.classList.contains('expanded') && bodyDiagram.classList.contains('scene4') && !bodyDiagram.classList.contains('scene5')) {
                bodyDiagram.classList.add('scene5');
                orbText.textContent = "";
                // Auto-advance to scene6 after animations complete
                setTimeout(() => {
                    if (bodyDiagram.classList.contains('scene5') && !bodyDiagram.classList.contains('scene6')) {
                        bodyDiagram.classList.add('scene6');
                        updateRoomOrbs();
                    }
                }, 3000);
                return;
            }

            // Scene 5 - wait for auto-advance
            if (bodyDiagram.classList.contains('expanded') && bodyDiagram.classList.contains('scene5') && !bodyDiagram.classList.contains('scene6')) {
                return;
            }

            // Scene 6 -> Scene 7 (room1 with 1 orb)
            if (bodyDiagram.classList.contains('expanded') && bodyDiagram.classList.contains('scene6') && !bodyDiagram.classList.contains('scene7')) {
                bodyDiagram.classList.add('scene7');
                updateRoomOrbs();
                return;
            }

            // Scene 7 -> Scene 8 (room2 with 2 orbs)
            if (bodyDiagram.classList.contains('expanded') && bodyDiagram.classList.contains('scene7') && !bodyDiagram.classList.contains('scene8')) {
                bodyDiagram.classList.add('scene8');
                updateRoomOrbs();
                return;
            }

            // Scene 8 -> Scene 9 (room3 with 4 orbs)
            if (bodyDiagram.classList.contains('expanded') && bodyDiagram.classList.contains('scene8') && !bodyDiagram.classList.contains('scene9')) {
                bodyDiagram.classList.add('scene9');
                updateRoomOrbs();
                return;
            }

            // Scene 9 -> Scene 10 (room4 with 5 orbs)
            if (bodyDiagram.classList.contains('expanded') && bodyDiagram.classList.contains('scene9') && !bodyDiagram.classList.contains('scene10')) {
                bodyDiagram.classList.add('scene10');
                updateRoomOrbs();
                return;
            }

            // Scene 10 -> Scene 11 (orbs animate, then room5 appears)
            if (bodyDiagram.classList.contains('expanded') && bodyDiagram.classList.contains('scene10') && !bodyDiagram.classList.contains('scene11')) {
                // Clear inline styles so CSS animations can work (except orb 6 - head orb stays in place)
                roomOrbs.forEach(orb => {
                    if (orb.dataset.roomOrb !== '6') {
                        orb.style.left = '';
                        orb.style.top = '';
                    }
                });
                bodyDiagram.classList.add('scene11');
                // After animation completes (1s), show room5
                setTimeout(() => {
                    if (bodyDiagram.classList.contains('scene11')) {
                        bodyDiagram.classList.add('animation-complete');
                    }
                }, 1000);
                return;
            }

            // Scene 11 -> Scene 12 (new text)
            if (bodyDiagram.classList.contains('expanded') && bodyDiagram.classList.contains('scene11') && !bodyDiagram.classList.contains('scene12')) {
                bodyDiagram.classList.add('scene12');
                return;
            }

            // Scene 12 slideshow - advance through slides
            // Default state shows read1, slides 2-6 advance through rest
            if (bodyDiagram.classList.contains('expanded') && bodyDiagram.classList.contains('scene12') && !bodyDiagram.classList.contains('scene13')) {
                if (bodyDiagram.classList.contains('slide-6')) {
                    // slide-6 -> scene13
                    bodyDiagram.classList.remove('slide-2', 'slide-3', 'slide-4', 'slide-5', 'slide-6');
                    bodyDiagram.classList.add('scene13');
                    return;
                }
                if (bodyDiagram.classList.contains('slide-5')) {
                    bodyDiagram.classList.remove('slide-5');
                    bodyDiagram.classList.add('slide-6');
                    return;
                }
                if (bodyDiagram.classList.contains('slide-4')) {
                    bodyDiagram.classList.remove('slide-4');
                    bodyDiagram.classList.add('slide-5');
                    return;
                }
                if (bodyDiagram.classList.contains('slide-3')) {
                    bodyDiagram.classList.remove('slide-3');
                    bodyDiagram.classList.add('slide-4');
                    return;
                }
                if (bodyDiagram.classList.contains('slide-2')) {
                    bodyDiagram.classList.remove('slide-2');
                    bodyDiagram.classList.add('slide-3');
                    return;
                }
                // Default (read1 showing) -> slide-2 (read2)
                bodyDiagram.classList.add('slide-2');
                return;
            }

            // Scene 13 slideshow - car images
            if (bodyDiagram.classList.contains('expanded') && bodyDiagram.classList.contains('scene13')) {
                if (bodyDiagram.classList.contains('slide-2')) {
                    // Final state - do nothing for now
                    return;
                }
                // Default (car1 showing) -> slide-2 (car2)
                bodyDiagram.classList.add('slide-2');
                return;
            }

            // Reset all visual states
            bodyDiagram.classList.remove('revealed');
            bodyDiagram.classList.remove('limited-active');
            bodyDiagram.classList.remove('flash-fill');
            bodyDiagram.classList.remove('expanded');
            bodyDiagram.classList.remove('scene2');
            bodyDiagram.classList.remove('scene3');
            bodyDiagram.classList.remove('scene4');
            bodyDiagram.classList.remove('scene5');
            bodyDiagram.classList.remove('scene6');
            bodyDiagram.classList.remove('scene7');
            bodyDiagram.classList.remove('scene8');
            bodyDiagram.classList.remove('scene9');
            bodyDiagram.classList.remove('scene10');
            bodyDiagram.classList.remove('scene11');
            bodyDiagram.classList.remove('scene12');
            bodyDiagram.classList.remove('scene13');
            bodyDiagram.classList.remove('animation-complete');
            bodyDiagram.classList.remove('slide-2');
            bodyDiagram.classList.remove('slide-3');
            bodyDiagram.classList.remove('slide-4');
            bodyDiagram.classList.remove('slide-5');
            bodyDiagram.classList.remove('slide-6');

            // Reset orb text
            orbText.textContent = scene1Text;

            // Reset body element visibility (clear inline styles set by JS)
            const bodyImg = bodyDiagram.querySelector('.body-image');
            const bodyFill = bodyDiagram.querySelector('.body-fill-overlay');
            const headOrbEl = bodyDiagram.querySelector('.head-orb');
            if (bodyImg) bodyImg.style.display = '';
            if (bodyFill) bodyFill.style.display = '';
            if (headOrbEl) headOrbEl.style.display = '';

            // Hide all body images
            bodyImages.forEach(img => img.classList.remove('visible'));

            // Hide all sense blocks
            senseBlocks.forEach(block => block.classList.remove('visible'));

            // Reset sequence state so animations can be triggered again
            sequenceState.limitedTriggered = false;
            sequenceState.infiniteTriggered = false;
            sequenceState.mindTriggered = false;
            sequenceState.gapTriggered = false;
            sequenceState.animationInProgress = false;
        });

        // ========== DO KEYWORD CLICK - EXPAND ORB WITH TEXT ==========
        const doKeyword = document.getElementById('do-keyword');
        let doArrowSvg = null;

        function triggerDo(isAutomatic = false) {
            flashKeyword(doKeyword);

            // Add grow animation if auto-triggered
            if (isAutomatic) {
                doKeyword.classList.remove('auto-trigger', 'auto-trigger-shrink');
                void doKeyword.offsetWidth; // Force reflow
                doKeyword.classList.add('auto-trigger');

                // Shrink back after expansion
                setTimeout(() => {
                    doKeyword.classList.remove('auto-trigger');
                    doKeyword.classList.add('auto-trigger-shrink');
                    setTimeout(() => doKeyword.classList.remove('auto-trigger-shrink'), 300);
                }, 600);
            }

            // Remove any existing arrow
            if (doArrowSvg) {
                doArrowSvg.remove();
            }

            bodyDiagram.classList.add('expanded');
            updateOrbPosition('scene1');

            // Draw arrow after expansion starts
            setTimeout(() => {
                const keywordRect = doKeyword.getBoundingClientRect();
                const textRect = orbText.getBoundingClientRect();
                const scrollX = window.scrollX;
                const scrollY = window.scrollY;

                // Start point: bottom center of "do" keyword
                const startX = keywordRect.left + keywordRect.width / 2 + scrollX;
                const startY = keywordRect.bottom + 5 + scrollY;

                // End point: top center of orb text
                const endX = textRect.left + textRect.width / 2 + scrollX;
                const endY = textRect.top - 10 + scrollY;

                // Create SVG for the arrow
                doArrowSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                doArrowSvg.classList.add('gap-arrow-svg');
                doArrowSvg.style.width = document.documentElement.scrollWidth + 'px';
                doArrowSvg.style.height = document.documentElement.scrollHeight + 'px';
                doArrowSvg.setAttribute('viewBox', `0 0 ${document.documentElement.scrollWidth} ${document.documentElement.scrollHeight}`);

                // Create curved path
                const midY = (startY + endY) / 2;
                const pathD = `M ${startX} ${startY} Q ${startX} ${midY}, ${endX} ${endY}`;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.classList.add('gap-arrow-line');
                path.setAttribute('d', pathD);

                // Create arrow head pointing down
                const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                arrowHead.classList.add('gap-arrow-head');
                arrowHead.setAttribute('points', `${endX},${endY + 5} ${endX - 8},${endY - 8} ${endX + 8},${endY - 8}`);

                doArrowSvg.appendChild(path);
                doArrowSvg.appendChild(arrowHead);
                document.body.appendChild(doArrowSvg);

                // Trigger animation
                requestAnimationFrame(() => {
                    path.classList.add('animating');
                    arrowHead.classList.add('animating');
                });

                // Remove arrow after a delay
                setTimeout(() => {
                    if (doArrowSvg) {
                        doArrowSvg.style.opacity = '0';
                        doArrowSvg.style.transition = 'opacity 0.5s ease';
                        setTimeout(() => {
                            if (doArrowSvg) {
                                doArrowSvg.remove();
                                doArrowSvg = null;
                            }
                        }, 500);
                    }
                }, 2000);

                // Auto-advance to scene2 after expansion
                setTimeout(() => {
                    if (bodyDiagram.classList.contains('expanded') && !bodyDiagram.classList.contains('scene2')) {
                        bodyDiagram.classList.add('scene2');
                        orbText.textContent = scene2Text;
                        updateOrbPosition('scene2');
                        updateScene2Orbs();
                    }
                    // Allow clicks now that animations are done
                    sequenceState.animationInProgress = false;
                }, 2500);
            }, 400);
        }

        doKeyword.addEventListener('click', (e) => {
            e.stopPropagation();

            // Block clicks during animations
            sequenceState.animationInProgress = true;

            // Check sequence: need limited, infinite, mind, and gap first
            if (!sequenceState.limitedTriggered && !sequenceState.infiniteTriggered && !sequenceState.mindTriggered && !sequenceState.gapTriggered) {
                triggerLimited(true);
                setTimeout(() => {
                    triggerInfinite(true);
                    setTimeout(() => {
                        triggerMind(true);
                        setTimeout(() => {
                            triggerGap(true);
                            setTimeout(() => {
                                triggerDo(true);
                            }, 2800);
                        }, mindDuration + 200);
                    }, infiniteDuration + 200);
                }, limitedDuration + 200);
            } else if (!sequenceState.infiniteTriggered && !sequenceState.mindTriggered && !sequenceState.gapTriggered) {
                triggerInfinite(true);
                setTimeout(() => {
                    triggerMind(true);
                    setTimeout(() => {
                        triggerGap(true);
                        setTimeout(() => {
                            triggerDo(true);
                        }, 2800);
                    }, mindDuration + 200);
                }, infiniteDuration + 200);
            } else if (!sequenceState.mindTriggered && !sequenceState.gapTriggered) {
                triggerMind(true);
                setTimeout(() => {
                    triggerGap(true);
                    setTimeout(() => {
                        triggerDo(true);
                    }, 2800);
                }, mindDuration + 200);
            } else if (!sequenceState.gapTriggered) {
                triggerGap(true);
                setTimeout(() => {
                    triggerDo(true);
                }, 2800);
            } else {
                // All done, just trigger do
                triggerDo(false);
            }
        });

        // ========== REALITY KEYWORD CLICK ANIMATION ==========
        // Click on "reality" to draw arrow to sticky note and reveal it

        const realityKeyword = document.getElementById('reality-keyword');
        const realityNote = document.getElementById('reality-note');
        let realityArrowSvg = null;

        realityKeyword.addEventListener('click', (e) => {
            e.stopPropagation();

            // If already revealed, just close it
            if (realityNote.classList.contains('revealed')) {
                realityNote.classList.remove('revealed');
                return;
            }

            // Remove any existing arrow
            if (realityArrowSvg) {
                realityArrowSvg.remove();
            }

            // Get positions with scroll offset for absolute positioning
            const keywordRect = realityKeyword.getBoundingClientRect();
            const noteRect = realityNote.getBoundingClientRect();
            const scrollX = window.scrollX;
            const scrollY = window.scrollY;

            // Start point: right side of keyword
            const startX = keywordRect.right + 5 + scrollX;
            const startY = keywordRect.top + keywordRect.height / 2 + scrollY;

            // End point: left side of sticky note
            const endX = noteRect.left - 5 + scrollX;
            const endY = noteRect.top + noteRect.height / 2 + scrollY;

            // Create SVG for the arrow
            realityArrowSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            realityArrowSvg.classList.add('gap-arrow-svg');
            realityArrowSvg.style.width = document.documentElement.scrollWidth + 'px';
            realityArrowSvg.style.height = document.documentElement.scrollHeight + 'px';
            realityArrowSvg.setAttribute('viewBox', `0 0 ${document.documentElement.scrollWidth} ${document.documentElement.scrollHeight}`);

            // Create curved path
            const midX = (startX + endX) / 2;
            const pathD = `M ${startX} ${startY} Q ${midX} ${startY - 30}, ${endX} ${endY}`;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.classList.add('gap-arrow-line');
            path.setAttribute('d', pathD);
            path.style.stroke = '#60a5fa'; // Blue for reality

            // Create arrow head pointing right
            const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            arrowHead.classList.add('gap-arrow-head');
            arrowHead.setAttribute('points', `${endX + 5},${endY} ${endX - 8},${endY - 6} ${endX - 8},${endY + 6}`);
            arrowHead.style.fill = '#60a5fa'; // Blue for reality

            realityArrowSvg.appendChild(path);
            realityArrowSvg.appendChild(arrowHead);
            document.body.appendChild(realityArrowSvg);

            // Trigger animation
            requestAnimationFrame(() => {
                path.classList.add('animating');
                arrowHead.classList.add('animating');
            });

            // Reveal the sticky note after arrow reaches
            setTimeout(() => {
                realityNote.classList.add('revealed');

                // Remove arrow after a delay
                setTimeout(() => {
                    if (realityArrowSvg) {
                        realityArrowSvg.style.opacity = '0';
                        realityArrowSvg.style.transition = 'opacity 0.5s ease';
                        setTimeout(() => {
                            realityArrowSvg.remove();
                            realityArrowSvg = null;
                        }, 500);
                    }
                }, 1500);
            }, 600);
        });
    </script>
</body>
</html>
